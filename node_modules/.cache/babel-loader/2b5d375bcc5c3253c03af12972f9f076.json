{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _immutabilityHelper = _interopRequireDefault(require(\"immutability-helper\"));\n\nvar _v = _interopRequireDefault(require(\"uuid/v1\"));\n\nconst LaneHelper = {\n  initialiseLanes: (state, {\n    lanes\n  }) => {\n    const newLanes = lanes.map(lane => {\n      lane.currentPage = 1;\n      lane.cards && lane.cards.forEach(c => c.laneId = lane.id);\n      return lane;\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  paginateLane: (state, {\n    laneId,\n    newCards,\n    nextPage\n  }) => {\n    const updatedLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: newCards\n    });\n    updatedLanes.find(lane => lane.id === laneId).currentPage = nextPage;\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  },\n  appendCardsToLane: (state, {\n    laneId,\n    newCards,\n    index\n  }) => {\n    const lane = state.lanes.find(lane => lane.id === laneId);\n    newCards = newCards.map(c => (0, _immutabilityHelper.default)(c, {\n      laneId: {\n        $set: laneId\n      }\n    })).filter(c => lane.cards.find(card => card.id === c.id) == null);\n    return state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        if (index !== undefined) {\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $splice: [[index, 0, ...newCards]]\n            }\n          });\n        } else {\n          const cardsToUpdate = [...lane.cards, ...newCards];\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $set: cardsToUpdate\n            }\n          });\n        }\n      } else {\n        return lane;\n      }\n    });\n  },\n  appendCardToLane: (state, {\n    laneId,\n    card,\n    index\n  }) => {\n    const newLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: [card],\n      index\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  addLane: (state, lane) => {\n    const newLane = (0, _objectSpread2.default)({\n      id: (0, _v.default)(),\n      cards: []\n    }, lane);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $push: [newLane]\n      }\n    });\n  },\n  updateLane: (state, updatedLane) => {\n    const newLanes = state.lanes.map(lane => {\n      if (updatedLane.id == lane.id) {\n        return (0, _objectSpread2.default)({}, lane, updatedLane);\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  removeCardFromLane: (state, {\n    laneId,\n    cardId\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        let newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardFromLane: (state, {\n    laneId,\n    card\n  }) => {\n    const laneIndex = state.lanes.findIndex(x => x.id === laneId);\n\n    if (laneIndex < 0) {\n      return state;\n    }\n\n    const cardIndex = state.lanes[laneIndex].cards.findIndex(x => x.id === card.id);\n\n    if (cardIndex < 0) {\n      return state;\n    }\n\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        [laneIndex]: {\n          cards: {\n            [cardIndex]: {\n              $set: card\n            }\n          }\n        }\n      }\n    });\n  },\n  moveCardAcrossLanes: (state, {\n    fromLaneId,\n    toLaneId,\n    cardId,\n    index\n  }) => {\n    let cardToMove = null;\n    const interimLanes = state.lanes.map(lane => {\n      if (lane.id === fromLaneId) {\n        cardToMove = lane.cards.find(card => card.id === cardId);\n        const newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    const updatedState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: interimLanes\n      }\n    });\n    return LaneHelper.appendCardToLane(updatedState, {\n      laneId: toLaneId,\n      card: cardToMove,\n      index: index\n    });\n  },\n  updateCardsForLane: (state, {\n    laneId,\n    cards\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateLanes: (state, lanes) => {\n    return (0, _objectSpread2.default)({}, state, {\n      lanes: lanes\n    });\n  },\n  moveLane: (state, {\n    oldIndex,\n    newIndex\n  }) => {\n    const laneToMove = state.lanes[oldIndex];\n    const tempState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $splice: [[oldIndex, 1]]\n      }\n    });\n    return (0, _immutabilityHelper.default)(tempState, {\n      lanes: {\n        $splice: [[newIndex, 0, laneToMove]]\n      }\n    });\n  },\n  removeLane: (state, {\n    laneId\n  }) => {\n    const updatedLanes = state.lanes.filter(lane => lane.id !== laneId);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  }\n};\nvar _default = LaneHelper;\nexports.default = _default;","map":{"version":3,"sources":["C:/Users/John Geliberte/Work/freelance/m1/node_modules/react-trello/dist/helpers/LaneHelper.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_objectSpread2","_immutabilityHelper","_v","LaneHelper","initialiseLanes","state","lanes","newLanes","map","lane","currentPage","cards","forEach","c","laneId","id","$set","paginateLane","newCards","nextPage","updatedLanes","appendCardsToLane","find","index","filter","card","undefined","$splice","cardsToUpdate","appendCardToLane","addLane","newLane","$push","updateLane","updatedLane","removeCardFromLane","cardId","updateCardFromLane","laneIndex","findIndex","x","cardIndex","moveCardAcrossLanes","fromLaneId","toLaneId","cardToMove","interimLanes","updatedState","updateCardsForLane","updateLanes","moveLane","oldIndex","newIndex","laneToMove","tempState","removeLane","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _immutabilityHelper = _interopRequireDefault(require(\"immutability-helper\"));\n\nvar _v = _interopRequireDefault(require(\"uuid/v1\"));\n\nconst LaneHelper = {\n  initialiseLanes: (state, {\n    lanes\n  }) => {\n    const newLanes = lanes.map(lane => {\n      lane.currentPage = 1;\n      lane.cards && lane.cards.forEach(c => c.laneId = lane.id);\n      return lane;\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  paginateLane: (state, {\n    laneId,\n    newCards,\n    nextPage\n  }) => {\n    const updatedLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: newCards\n    });\n    updatedLanes.find(lane => lane.id === laneId).currentPage = nextPage;\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  },\n  appendCardsToLane: (state, {\n    laneId,\n    newCards,\n    index\n  }) => {\n    const lane = state.lanes.find(lane => lane.id === laneId);\n    newCards = newCards.map(c => (0, _immutabilityHelper.default)(c, {\n      laneId: {\n        $set: laneId\n      }\n    })).filter(c => lane.cards.find(card => card.id === c.id) == null);\n    return state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        if (index !== undefined) {\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $splice: [[index, 0, ...newCards]]\n            }\n          });\n        } else {\n          const cardsToUpdate = [...lane.cards, ...newCards];\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $set: cardsToUpdate\n            }\n          });\n        }\n      } else {\n        return lane;\n      }\n    });\n  },\n  appendCardToLane: (state, {\n    laneId,\n    card,\n    index\n  }) => {\n    const newLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: [card],\n      index\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  addLane: (state, lane) => {\n    const newLane = (0, _objectSpread2.default)({\n      id: (0, _v.default)(),\n      cards: []\n    }, lane);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $push: [newLane]\n      }\n    });\n  },\n  updateLane: (state, updatedLane) => {\n    const newLanes = state.lanes.map(lane => {\n      if (updatedLane.id == lane.id) {\n        return (0, _objectSpread2.default)({}, lane, updatedLane);\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  removeCardFromLane: (state, {\n    laneId,\n    cardId\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        let newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardFromLane: (state, {\n    laneId,\n    card\n  }) => {\n    const laneIndex = state.lanes.findIndex(x => x.id === laneId);\n\n    if (laneIndex < 0) {\n      return state;\n    }\n\n    const cardIndex = state.lanes[laneIndex].cards.findIndex(x => x.id === card.id);\n\n    if (cardIndex < 0) {\n      return state;\n    }\n\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        [laneIndex]: {\n          cards: {\n            [cardIndex]: {\n              $set: card\n            }\n          }\n        }\n      }\n    });\n  },\n  moveCardAcrossLanes: (state, {\n    fromLaneId,\n    toLaneId,\n    cardId,\n    index\n  }) => {\n    let cardToMove = null;\n    const interimLanes = state.lanes.map(lane => {\n      if (lane.id === fromLaneId) {\n        cardToMove = lane.cards.find(card => card.id === cardId);\n        const newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    const updatedState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: interimLanes\n      }\n    });\n    return LaneHelper.appendCardToLane(updatedState, {\n      laneId: toLaneId,\n      card: cardToMove,\n      index: index\n    });\n  },\n  updateCardsForLane: (state, {\n    laneId,\n    cards\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateLanes: (state, lanes) => {\n    return (0, _objectSpread2.default)({}, state, {\n      lanes: lanes\n    });\n  },\n  moveLane: (state, {\n    oldIndex,\n    newIndex\n  }) => {\n    const laneToMove = state.lanes[oldIndex];\n    const tempState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $splice: [[oldIndex, 1]]\n      }\n    });\n    return (0, _immutabilityHelper.default)(tempState, {\n      lanes: {\n        $splice: [[newIndex, 0, laneToMove]]\n      }\n    });\n  },\n  removeLane: (state, {\n    laneId\n  }) => {\n    const updatedLanes = state.lanes.filter(lane => lane.id !== laneId);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  }\n};\nvar _default = LaneHelper;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}