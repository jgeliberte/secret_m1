{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { CellNavigationMode, Z_INDEXES } from '../common/enums';\nimport * as rowUtils from '../RowUtils';\nimport { isFrozen, canEdit } from '../ColumnUtils';\n\nvar getRowTop = function (rowIdx, rowHeight) {\n  return rowIdx * rowHeight;\n};\n\nexport function getSelectedDimensions(_a) {\n  var _b = _a.selectedPosition,\n      idx = _b.idx,\n      rowIdx = _b.rowIdx,\n      columns = _a.columns,\n      rowHeight = _a.rowHeight,\n      scrollLeft = _a.scrollLeft;\n\n  if (idx < 0) {\n    return {\n      width: 0,\n      left: 0,\n      top: 0,\n      height: rowHeight,\n      zIndex: 1\n    };\n  }\n\n  var column = columns[idx];\n  var frozen = isFrozen(column);\n  var width = column.width;\n  var left = frozen ? column.left + scrollLeft : column.left;\n  var top = getRowTop(rowIdx, rowHeight);\n  var zIndex = frozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n  return {\n    width: width,\n    left: left,\n    top: top,\n    height: rowHeight,\n    zIndex: zIndex\n  };\n}\nexport function getSelectedRangeDimensions(_a) {\n  var _b = _a.selectedRange,\n      topLeft = _b.topLeft,\n      bottomRight = _b.bottomRight,\n      columns = _a.columns,\n      rowHeight = _a.rowHeight;\n\n  if (topLeft.idx < 0) {\n    return {\n      width: 0,\n      left: 0,\n      top: 0,\n      height: rowHeight,\n      zIndex: Z_INDEXES.CELL_MASK\n    };\n  }\n\n  var width = 0;\n  var anyColFrozen = false;\n\n  for (var i = topLeft.idx; i <= bottomRight.idx; i++) {\n    var column = columns[i];\n    width += column.width;\n    anyColFrozen = anyColFrozen || isFrozen(column);\n  }\n\n  var left = columns[topLeft.idx].left;\n  var top = getRowTop(topLeft.rowIdx, rowHeight);\n  var height = (bottomRight.rowIdx - topLeft.rowIdx + 1) * rowHeight;\n  var zIndex = anyColFrozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n  return {\n    width: width,\n    left: left,\n    top: top,\n    height: height,\n    zIndex: zIndex\n  };\n}\nexport function getSelectedCellValue(_a) {\n  var selectedPosition = _a.selectedPosition,\n      columns = _a.columns,\n      rowGetter = _a.rowGetter;\n  var column = columns[selectedPosition.idx];\n  var row = rowGetter(selectedPosition.rowIdx);\n  return row && column ? rowUtils.get(row, column.key) : null;\n}\nexport function isSelectedCellEditable(_a) {\n  var enableCellSelect = _a.enableCellSelect,\n      selectedPosition = _a.selectedPosition,\n      columns = _a.columns,\n      rowGetter = _a.rowGetter,\n      onCheckCellIsEditable = _a.onCheckCellIsEditable;\n  var column = columns[selectedPosition.idx];\n  var row = rowGetter(selectedPosition.rowIdx);\n  var isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable(__assign({\n    row: row,\n    column: column\n  }, selectedPosition)) : true;\n  return isCellEditable && canEdit(column, row, enableCellSelect);\n}\nexport function getNextSelectedCellPosition(_a) {\n  var cellNavigationMode = _a.cellNavigationMode,\n      columns = _a.columns,\n      rowsCount = _a.rowsCount,\n      nextPosition = _a.nextPosition;\n\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    var idx = nextPosition.idx,\n        rowIdx = nextPosition.rowIdx;\n    var columnsCount = columns.length;\n    var isAfterLastColumn = idx === columnsCount;\n    var isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        var isLastRow = rowIdx === rowsCount - 1;\n\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx: rowIdx,\n          idx: 0,\n          changeRowOrColumn: true\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        var isFirstRow = rowIdx === 0;\n\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx: rowIdx,\n          idx: columnsCount - 1,\n          changeRowOrColumn: true\n        };\n      }\n    }\n  }\n\n  return __assign(__assign({}, nextPosition), {\n    changeRowOrColumn: false\n  });\n}\nexport function canExitGrid(event, _a) {\n  var cellNavigationMode = _a.cellNavigationMode,\n      columns = _a.columns,\n      rowsCount = _a.rowsCount,\n      _b = _a.selectedPosition,\n      rowIdx = _b.rowIdx,\n      idx = _b.idx; // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    var atLastCellInRow = idx === columns.length - 1;\n    var atFirstCellInRow = idx === 0;\n    var atLastRow = rowIdx === rowsCount - 1;\n    var atFirstRow = rowIdx === 0;\n    var shift = event.shiftKey === true;\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\nexport function selectedRangeIsSingleCell(_a) {\n  var topLeft = _a.topLeft,\n      bottomRight = _a.bottomRight;\n  return topLeft.idx === bottomRight.idx && topLeft.rowIdx === bottomRight.rowIdx;\n}","map":{"version":3,"sources":["../../src/utils/SelectedCellUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { CellNavigationMode, Z_INDEXES } from '../common/enums';\nimport * as rowUtils from '../RowUtils';\nimport { isFrozen, canEdit } from '../ColumnUtils';\nimport { CalculatedColumn, Position, Range, Dimension, RowGetter } from '../common/types';\n\nconst getRowTop = (rowIdx: number, rowHeight: number): number => rowIdx * rowHeight;\n\ninterface getSelectedDimensionsOpts<R> {\n  selectedPosition: Position;\n  columns: CalculatedColumn<R>[];\n  rowHeight: number;\n  scrollLeft: number;\n}\n\nexport function getSelectedDimensions<R>({ selectedPosition: { idx, rowIdx }, columns, rowHeight, scrollLeft }: getSelectedDimensionsOpts<R>): Dimension {\n  if (idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: 1 };\n  }\n  const column = columns[idx];\n  const frozen = isFrozen(column);\n  const { width } = column;\n  const left = frozen ? column.left + scrollLeft : column.left;\n  const top = getRowTop(rowIdx, rowHeight);\n  const zIndex = frozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n  return { width, left, top, height: rowHeight, zIndex };\n}\n\ninterface getSelectedRangeDimensionsOpts<R> {\n  selectedRange: Range;\n  columns: CalculatedColumn<R>[];\n  rowHeight: number;\n}\n\nexport function getSelectedRangeDimensions<R>({ selectedRange: { topLeft, bottomRight }, columns, rowHeight }: getSelectedRangeDimensionsOpts<R>): Dimension {\n  if (topLeft.idx < 0) {\n    return { width: 0, left: 0, top: 0, height: rowHeight, zIndex: Z_INDEXES.CELL_MASK };\n  }\n\n  let width = 0;\n  let anyColFrozen = false;\n  for (let i = topLeft.idx; i <= bottomRight.idx; i++) {\n    const column = columns[i];\n    width += column.width;\n    anyColFrozen = anyColFrozen || isFrozen(column);\n  }\n\n  const { left } = columns[topLeft.idx];\n  const top = getRowTop(topLeft.rowIdx, rowHeight);\n  const height = (bottomRight.rowIdx - topLeft.rowIdx + 1) * rowHeight;\n  const zIndex = anyColFrozen ? Z_INDEXES.FROZEN_CELL_MASK : Z_INDEXES.CELL_MASK;\n\n  return { width, left, top, height, zIndex };\n}\n\ninterface getSelectedCellValueOpts<R> {\n  selectedPosition: Position;\n  columns: CalculatedColumn<R>[];\n  rowGetter: RowGetter<R>;\n}\n\nexport function getSelectedCellValue<R>({ selectedPosition, columns, rowGetter }: getSelectedCellValueOpts<R>) {\n  const column = columns[selectedPosition.idx];\n  const row = rowGetter(selectedPosition.rowIdx);\n\n  return row && column ? rowUtils.get(row, column.key) : null;\n}\n\ninterface isSelectedCellEditableOpts<R> {\n  enableCellSelect: boolean;\n  selectedPosition: Position;\n  columns: CalculatedColumn<R>[];\n  rowGetter: RowGetter<R>;\n  onCheckCellIsEditable?(arg: { row: R; column: CalculatedColumn<R> } & Position): boolean;\n}\n\nexport function isSelectedCellEditable<R>({ enableCellSelect, selectedPosition, columns, rowGetter, onCheckCellIsEditable }: isSelectedCellEditableOpts<R>): boolean {\n  const column = columns[selectedPosition.idx];\n  const row = rowGetter(selectedPosition.rowIdx);\n  const isCellEditable = onCheckCellIsEditable ? onCheckCellIsEditable({ row, column, ...selectedPosition }) : true;\n  return isCellEditable && canEdit<R>(column, row, enableCellSelect);\n}\n\ninterface getNextSelectedCellPositionOpts<R> {\n  cellNavigationMode: CellNavigationMode;\n  columns: CalculatedColumn<R>[];\n  rowsCount: number;\n  nextPosition: Position;\n}\n\nexport interface NextSelectedCellPosition extends Position {\n  changeRowOrColumn: boolean;\n}\n\nexport function getNextSelectedCellPosition<R>({ cellNavigationMode, columns, rowsCount, nextPosition }: getNextSelectedCellPositionOpts<R>): NextSelectedCellPosition {\n  if (cellNavigationMode !== CellNavigationMode.NONE) {\n    const { idx, rowIdx } = nextPosition;\n    const columnsCount = columns.length;\n    const isAfterLastColumn = idx === columnsCount;\n    const isBeforeFirstColumn = idx === -1;\n\n    if (isAfterLastColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isLastRow = rowIdx === rowsCount - 1;\n        if (!isLastRow) {\n          return {\n            idx: 0,\n            rowIdx: rowIdx + 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: 0,\n          changeRowOrColumn: true\n        };\n      }\n    } else if (isBeforeFirstColumn) {\n      if (cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n        const isFirstRow = rowIdx === 0;\n        if (!isFirstRow) {\n          return {\n            rowIdx: rowIdx - 1,\n            idx: columnsCount - 1,\n            changeRowOrColumn: true\n          };\n        }\n      } else if (cellNavigationMode === CellNavigationMode.LOOP_OVER_ROW) {\n        return {\n          rowIdx,\n          idx: columnsCount - 1,\n          changeRowOrColumn: true\n        };\n      }\n    }\n  }\n\n  return { ...nextPosition, changeRowOrColumn: false };\n}\n\ninterface canExitGridOpts<R> {\n  cellNavigationMode: CellNavigationMode;\n  columns: CalculatedColumn<R>[];\n  rowsCount: number;\n  selectedPosition: Position;\n}\n\nexport function canExitGrid<R>(event: React.KeyboardEvent, { cellNavigationMode, columns, rowsCount, selectedPosition: { rowIdx, idx } }: canExitGridOpts<R>): boolean {\n  // When the cellNavigationMode is 'none' or 'changeRow', you can exit the grid if you're at the first or last cell of the grid\n  // When the cellNavigationMode is 'loopOverRow', there is no logical exit point so you can't exit the grid\n  if (cellNavigationMode === CellNavigationMode.NONE || cellNavigationMode === CellNavigationMode.CHANGE_ROW) {\n    const atLastCellInRow = idx === columns.length - 1;\n    const atFirstCellInRow = idx === 0;\n    const atLastRow = rowIdx === rowsCount - 1;\n    const atFirstRow = rowIdx === 0;\n    const shift = event.shiftKey === true;\n\n    return shift ? atFirstCellInRow && atFirstRow : atLastCellInRow && atLastRow;\n  }\n\n  return false;\n}\n\nexport function selectedRangeIsSingleCell({ topLeft, bottomRight }: Range): boolean {\n  return topLeft.idx === bottomRight.idx && topLeft.rowIdx === bottomRight.rowIdx;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}