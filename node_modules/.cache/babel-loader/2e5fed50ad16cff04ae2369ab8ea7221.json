{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport React, { cloneElement } from 'react';\nimport { isElement } from 'react-is'; // Components\n\nimport SelectionMask from './SelectionMask';\nimport SelectionRangeMask from './SelectionRangeMask';\nimport CopyMask from './CopyMask';\nimport DragMask from './DragMask';\nimport DragHandle from './DragHandle';\nimport EditorContainer from '../common/editors/EditorContainer';\nimport EditorPortal from '../common/editors/EditorPortal'; // Utils\n\nimport { isKeyPrintable, isCtrlKeyHeldDown } from '../common/utils/keyboardUtils';\nimport { getSelectedDimensions, getSelectedCellValue, getSelectedRangeDimensions, getNextSelectedCellPosition, canExitGrid, isSelectedCellEditable, selectedRangeIsSingleCell } from '../utils/SelectedCellUtils';\nimport { isFrozen } from '../ColumnUtils';\nimport keyCodes from '../KeyCodes'; // Types\n\nimport { UpdateActions, CellNavigationMode, EventTypes } from '../common/enums';\nvar SCROLL_CELL_BUFFER = 2;\n\nvar InteractionMasks =\n/** @class */\nfunction (_super) {\n  __extends(InteractionMasks, _super);\n\n  function InteractionMasks() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.state = {\n      selectedPosition: {\n        idx: -1,\n        rowIdx: -1\n      },\n      selectedRange: {\n        topLeft: {\n          idx: -1,\n          rowIdx: -1\n        },\n        bottomRight: {\n          idx: -1,\n          rowIdx: -1\n        },\n        startCell: null,\n        cursorCell: null,\n        isDragging: false\n      },\n      copiedPosition: null,\n      draggedPosition: null,\n      editorPosition: null,\n      isEditorEnabled: false,\n      firstEditorKeyPress: null\n    };\n    _this.selectionMask = React.createRef();\n    _this.copyMask = React.createRef();\n    _this.unsubscribeEventHandlers = [];\n\n    _this.onKeyDown = function (e) {\n      if (isCtrlKeyHeldDown(e)) {\n        _this.onPressKeyWithCtrl(e);\n      } else if (e.keyCode === keyCodes.Escape) {\n        _this.onPressEscape();\n      } else if (e.keyCode === keyCodes.Tab) {\n        _this.onPressTab(e);\n      } else if (_this.isKeyboardNavigationEvent(e)) {\n        _this.changeCellFromEvent(e);\n      } else if (isKeyPrintable(e.keyCode) || [keyCodes.Backspace, keyCodes.Delete, keyCodes.Enter].includes(e.keyCode)) {\n        _this.openEditor(e);\n      }\n    };\n\n    _this.openEditor = function (event) {\n      if (_this.isSelectedCellEditable() && !_this.state.isEditorEnabled) {\n        _this.setState({\n          isEditorEnabled: true,\n          firstEditorKeyPress: event ? event.key : null,\n          editorPosition: _this.getEditorPosition()\n        });\n      }\n    };\n\n    _this.onFocus = function () {\n      var _a = _this.state.selectedPosition,\n          idx = _a.idx,\n          rowIdx = _a.rowIdx;\n\n      if (idx === -1 && rowIdx === -1) {\n        _this.selectFirstCell();\n      }\n    };\n\n    _this.selectCell = function (cell, openEditor) {\n      var callback = openEditor ? _this.openEditor : undefined; // Close the editor to commit any pending changes\n\n      if (_this.state.isEditorEnabled) {\n        _this.closeEditor();\n      }\n\n      _this.setState(function () {\n        if (!_this.isCellWithinBounds(cell)) return null;\n        return {\n          selectedPosition: cell,\n          selectedRange: {\n            topLeft: cell,\n            bottomRight: cell,\n            startCell: cell,\n            cursorCell: cell,\n            isDragging: false\n          }\n        };\n      }, callback);\n    };\n\n    _this.onSelectCellRangeStarted = function (selectedPosition) {\n      _this.setState({\n        selectedRange: _this.createSingleCellSelectedRange(selectedPosition, true),\n        selectedPosition: selectedPosition\n      }, function () {\n        if (_this.props.onCellRangeSelectionStarted) {\n          _this.props.onCellRangeSelectionStarted(_this.state.selectedRange);\n        }\n      });\n    };\n\n    _this.onSelectCellRangeUpdated = function (cellPosition, isFromKeyboard, callback) {\n      if (!_this.state.selectedRange.isDragging && !isFromKeyboard || !_this.isCellWithinBounds(cellPosition)) {\n        return;\n      }\n\n      var startCell = _this.state.selectedRange.startCell || _this.state.selectedPosition;\n      var colIdxs = [startCell.idx, cellPosition.idx].sort(function (a, b) {\n        return a - b;\n      });\n      var rowIdxs = [startCell.rowIdx, cellPosition.rowIdx].sort(function (a, b) {\n        return a - b;\n      });\n      var topLeft = {\n        idx: colIdxs[0],\n        rowIdx: rowIdxs[0]\n      };\n      var bottomRight = {\n        idx: colIdxs[1],\n        rowIdx: rowIdxs[1]\n      };\n\n      var selectedRange = __assign(__assign({}, _this.state.selectedRange), {\n        // default the startCell to the selected cell, in case we've just started via keyboard\n        startCell: _this.state.selectedRange.startCell || _this.state.selectedPosition,\n        // assign the new state - the bounds of the range, and the new cursor cell\n        topLeft: topLeft,\n        bottomRight: bottomRight,\n        cursorCell: cellPosition\n      });\n\n      _this.setState({\n        selectedRange: selectedRange\n      }, function () {\n        if (_this.props.onCellRangeSelectionUpdated) {\n          _this.props.onCellRangeSelectionUpdated(_this.state.selectedRange);\n        }\n\n        if (callback) {\n          callback();\n        }\n      });\n    };\n\n    _this.onSelectCellRangeEnded = function () {\n      var selectedRange = __assign(__assign({}, _this.state.selectedRange), {\n        isDragging: false\n      });\n\n      _this.setState({\n        selectedRange: selectedRange\n      }, function () {\n        if (_this.props.onCellRangeSelectionCompleted) {\n          _this.props.onCellRangeSelectionCompleted(_this.state.selectedRange);\n        } // Focus the InteractionMasks, so it can receive keyboard events\n        // _this.focus();//////////////////////////////////////////////////////////////////////////\n\n      });\n    };\n\n    _this.handleDragStart = function (e) {\n      var selectedPosition = _this.state.selectedPosition; // To prevent dragging down/up when reordering rows. (TODO: is this required)\n\n      if (selectedPosition.idx > -1) {\n        e.dataTransfer.effectAllowed = 'copy'; // Setting data is required to make an element draggable in FF\n\n        var transferData = JSON.stringify(selectedPosition);\n\n        try {\n          e.dataTransfer.setData('text/plain', transferData);\n        } catch (ex) {\n          // IE only supports 'text' and 'URL' for the 'type' argument\n          e.dataTransfer.setData('text', transferData);\n        }\n\n        _this.setState({\n          draggedPosition: __assign(__assign({}, selectedPosition), {\n            overRowIdx: selectedPosition.rowIdx\n          })\n        });\n      }\n    };\n\n    _this.handleDragEnter = function (overRowIdx) {\n      _this.setState(function (_a) {\n        var draggedPosition = _a.draggedPosition;\n\n        if (draggedPosition) {\n          return {\n            draggedPosition: __assign(__assign({}, draggedPosition), {\n              overRowIdx: overRowIdx\n            })\n          };\n        }\n\n        return null;\n      });\n    };\n\n    _this.handleDragEnd = function () {\n      var _a;\n\n      var draggedPosition = _this.state.draggedPosition;\n      if (draggedPosition === null) return;\n      var rowIdx = draggedPosition.rowIdx,\n          overRowIdx = draggedPosition.overRowIdx;\n      var _b = _this.props,\n          columns = _b.columns,\n          onGridRowsUpdated = _b.onGridRowsUpdated,\n          rowGetter = _b.rowGetter;\n      var column = columns[draggedPosition.idx];\n      var value = getSelectedCellValue({\n        selectedPosition: draggedPosition,\n        columns: columns,\n        rowGetter: rowGetter\n      });\n      var cellKey = column.key;\n      var fromRow = rowIdx < overRowIdx ? rowIdx : overRowIdx;\n      var toRow = rowIdx > overRowIdx ? rowIdx : overRowIdx;\n      onGridRowsUpdated(cellKey, fromRow, toRow, (_a = {}, _a[cellKey] = value, _a), UpdateActions.CELL_DRAG);\n\n      _this.setState({\n        draggedPosition: null\n      });\n    };\n\n    _this.onDragHandleDoubleClick = function () {\n      var _a = _this.props,\n          onDragHandleDoubleClick = _a.onDragHandleDoubleClick,\n          rowGetter = _a.rowGetter;\n      var selectedPosition = _this.state.selectedPosition;\n      var idx = selectedPosition.idx,\n          rowIdx = selectedPosition.rowIdx;\n      var rowData = rowGetter(selectedPosition.rowIdx);\n      onDragHandleDoubleClick({\n        idx: idx,\n        rowIdx: rowIdx,\n        rowData: rowData\n      });\n    };\n\n    _this.onCommit = function (args) {\n      _this.props.onCommit(args);\n\n      _this.closeEditor();\n    };\n\n    _this.onCommitCancel = function () {\n      _this.closeEditor();\n    };\n\n    _this.getSelectedDimensions = function (selectedPosition, useGridColumns) {\n      var _a = _this.props,\n          scrollLeft = _a.scrollLeft,\n          getRowHeight = _a.getRowHeight,\n          getRowTop = _a.getRowTop,\n          getRowColumns = _a.getRowColumns,\n          gridColumns = _a.columns;\n      var columns = useGridColumns ? gridColumns : getRowColumns(selectedPosition.rowIdx);\n      var top = getRowTop(selectedPosition.rowIdx);\n      var rowHeight = getRowHeight(selectedPosition.rowIdx);\n      var dimension = getSelectedDimensions({\n        selectedPosition: selectedPosition,\n        columns: columns,\n        scrollLeft: scrollLeft,\n        rowHeight: rowHeight\n      });\n      dimension.top = top;\n      return dimension;\n    };\n\n    return _this;\n  }\n\n  InteractionMasks.prototype.componentDidUpdate = function (prevProps, prevState) {\n    var _a = this.state,\n        selectedPosition = _a.selectedPosition,\n        isEditorEnabled = _a.isEditorEnabled;\n    var prevSelectedPosition = prevState.selectedPosition,\n        prevIsEditorEnabled = prevState.isEditorEnabled;\n    var isSelectedPositionChanged = selectedPosition !== prevSelectedPosition && (selectedPosition.rowIdx !== prevSelectedPosition.rowIdx || selectedPosition.idx !== prevSelectedPosition.idx);\n    var isEditorClosed = isEditorEnabled !== prevIsEditorEnabled && !isEditorEnabled;\n\n    if (isSelectedPositionChanged) {\n      // Call event handlers if selected cell has changed\n      var _b = this.props,\n          onCellSelected = _b.onCellSelected,\n          onCellDeSelected = _b.onCellDeSelected;\n\n      if (onCellDeSelected && this.isCellWithinBounds(prevSelectedPosition)) {\n        onCellDeSelected(__assign({}, prevSelectedPosition));\n      }\n\n      if (onCellSelected && this.isCellWithinBounds(selectedPosition)) {\n        onCellSelected(__assign({}, selectedPosition));\n      }\n    }\n\n    if (isSelectedPositionChanged && this.isCellWithinBounds(selectedPosition) || isEditorClosed) {\n      this.focus();\n    }\n  };\n\n  InteractionMasks.prototype.componentDidMount = function () {\n    var _a = this.props,\n        eventBus = _a.eventBus,\n        enableCellAutoFocus = _a.enableCellAutoFocus;\n    this.unsubscribeEventHandlers = [eventBus.subscribe(EventTypes.SELECT_CELL, this.selectCell), eventBus.subscribe(EventTypes.SELECT_START, this.onSelectCellRangeStarted), eventBus.subscribe(EventTypes.SELECT_UPDATE, this.onSelectCellRangeUpdated), eventBus.subscribe(EventTypes.SELECT_END, this.onSelectCellRangeEnded), eventBus.subscribe(EventTypes.DRAG_ENTER, this.handleDragEnter)];\n\n    if (enableCellAutoFocus && this.isFocusedOnBody()) {\n      this.selectFirstCell();\n    }\n  };\n\n  InteractionMasks.prototype.componentWillUnmount = function () {\n    this.unsubscribeEventHandlers.forEach(function (h) {\n      return h();\n    });\n  };\n\n  InteractionMasks.prototype.getEditorPosition = function () {\n    if (!this.selectionMask.current) return null;\n    var editorPortalTarget = this.props.editorPortalTarget;\n\n    var _a = this.selectionMask.current.getBoundingClientRect(),\n        selectionMaskLeft = _a.left,\n        selectionMaskTop = _a.top;\n\n    if (editorPortalTarget === document.body) {\n      var _b = document.scrollingElement || document.documentElement,\n          scrollLeft_1 = _b.scrollLeft,\n          scrollTop_1 = _b.scrollTop;\n\n      return {\n        left: selectionMaskLeft + scrollLeft_1,\n        top: selectionMaskTop + scrollTop_1\n      };\n    }\n\n    var _c = editorPortalTarget.getBoundingClientRect(),\n        portalTargetLeft = _c.left,\n        portalTargetTop = _c.top;\n\n    var scrollLeft = editorPortalTarget.scrollLeft,\n        scrollTop = editorPortalTarget.scrollTop;\n    return {\n      left: selectionMaskLeft - portalTargetLeft + scrollLeft,\n      top: selectionMaskTop - portalTargetTop + scrollTop\n    };\n  };\n\n  InteractionMasks.prototype.setMaskScollLeft = function (mask, position, scrollLeft) {\n    if (!mask || !position) return;\n    var idx = position.idx,\n        rowIdx = position.rowIdx;\n    if (!(idx >= 0 && rowIdx >= 0)) return;\n    var column = this.props.columns[idx];\n    if (!isFrozen(column)) return;\n    var top = this.props.getRowTop(rowIdx);\n    var left = scrollLeft + column.left;\n    var transform = \"translate(\" + left + \"px, \" + top + \"px)\";\n\n    if (mask.style.transform !== transform) {\n      mask.style.transform = transform;\n    }\n  };\n  /**\r\n   * Sets the position of SelectionMask and CopyMask components when the canvas is scrolled\r\n   * This is only required on the frozen columns\r\n   */\n\n\n  InteractionMasks.prototype.setScrollLeft = function (scrollLeft) {\n    this.setMaskScollLeft(this.selectionMask.current, this.state.selectedPosition, scrollLeft);\n    this.setMaskScollLeft(this.copyMask.current, this.state.copiedPosition, scrollLeft);\n  };\n\n  InteractionMasks.prototype.isSelectedCellEditable = function () {\n    var _a = this.props,\n        enableCellSelect = _a.enableCellSelect,\n        columns = _a.columns,\n        rowGetter = _a.rowGetter,\n        onCheckCellIsEditable = _a.onCheckCellIsEditable;\n    var selectedPosition = this.state.selectedPosition;\n    return isSelectedCellEditable({\n      enableCellSelect: enableCellSelect,\n      columns: columns,\n      rowGetter: rowGetter,\n      selectedPosition: selectedPosition,\n      onCheckCellIsEditable: onCheckCellIsEditable\n    });\n  };\n\n  InteractionMasks.prototype.closeEditor = function () {\n    this.setState({\n      isEditorEnabled: false,\n      firstEditorKeyPress: null,\n      editorPosition: null\n    });\n  };\n\n  InteractionMasks.prototype.onPressKeyWithCtrl = function (_a) {\n    var keyCode = _a.keyCode;\n\n    if (this.copyPasteEnabled()) {\n      if (keyCode === keyCodes.c) {\n        var _b = this.props,\n            columns = _b.columns,\n            rowGetter = _b.rowGetter;\n        var selectedPosition = this.state.selectedPosition;\n        var value = getSelectedCellValue({\n          selectedPosition: selectedPosition,\n          columns: columns,\n          rowGetter: rowGetter\n        });\n        this.handleCopy(value);\n      } else if (keyCode === keyCodes.v) {\n        this.handlePaste();\n      }\n    }\n  };\n\n  InteractionMasks.prototype.onPressTab = function (e) {\n    var _a = this.props,\n        cellNavigationMode = _a.cellNavigationMode,\n        columns = _a.columns,\n        rowsCount = _a.rowsCount;\n    var _b = this.state,\n        selectedPosition = _b.selectedPosition,\n        isEditorEnabled = _b.isEditorEnabled; // When there are no rows in the grid, we need to allow the browser to handle tab presses\n\n    if (rowsCount === 0) {\n      return;\n    } // If we are in a position to leave the grid, stop editing but stay in that cell\n\n\n    if (canExitGrid(e, {\n      cellNavigationMode: cellNavigationMode,\n      columns: columns,\n      rowsCount: rowsCount,\n      selectedPosition: selectedPosition\n    })) {\n      if (isEditorEnabled) {\n        this.closeEditor();\n        return;\n      } // Reset the selected position before exiting\n\n\n      this.setState({\n        selectedPosition: {\n          idx: -1,\n          rowIdx: -1\n        }\n      });\n      return;\n    }\n\n    this.changeCellFromEvent(e);\n  };\n\n  InteractionMasks.prototype.onPressEscape = function () {\n    if (this.copyPasteEnabled()) {\n      this.handleCancelCopy();\n      this.closeEditor();\n    }\n  };\n\n  InteractionMasks.prototype.copyPasteEnabled = function () {\n    return this.props.onCellCopyPaste !== null && this.isSelectedCellEditable();\n  };\n\n  InteractionMasks.prototype.handleCopy = function (value) {\n    var _a = this.state.selectedPosition,\n        rowIdx = _a.rowIdx,\n        idx = _a.idx;\n    this.setState({\n      copiedPosition: {\n        rowIdx: rowIdx,\n        idx: idx,\n        value: value\n      }\n    });\n  };\n\n  InteractionMasks.prototype.handleCancelCopy = function () {\n    this.setState({\n      copiedPosition: null\n    });\n  };\n\n  InteractionMasks.prototype.handlePaste = function () {\n    var _a;\n\n    var _b = this.props,\n        columns = _b.columns,\n        onCellCopyPaste = _b.onCellCopyPaste,\n        onGridRowsUpdated = _b.onGridRowsUpdated;\n    var _c = this.state,\n        selectedPosition = _c.selectedPosition,\n        copiedPosition = _c.copiedPosition;\n    var toRow = selectedPosition.rowIdx;\n\n    if (copiedPosition === null) {\n      return;\n    }\n\n    var cellKey = columns[selectedPosition.idx].key;\n    var fromRow = copiedPosition.rowIdx,\n        value = copiedPosition.value;\n\n    if (onCellCopyPaste) {\n      onCellCopyPaste({\n        cellKey: cellKey,\n        rowIdx: toRow,\n        fromRow: fromRow,\n        toRow: toRow,\n        value: value\n      });\n    }\n\n    onGridRowsUpdated(cellKey, toRow, toRow, (_a = {}, _a[cellKey] = value, _a), UpdateActions.COPY_PASTE, fromRow);\n  };\n\n  InteractionMasks.prototype.isKeyboardNavigationEvent = function (e) {\n    return this.getKeyNavActionFromEvent(e) !== null;\n  };\n\n  InteractionMasks.prototype.getKeyNavActionFromEvent = function (e) {\n    var _a = this.props,\n        rowVisibleEndIdx = _a.rowVisibleEndIdx,\n        rowVisibleStartIdx = _a.rowVisibleStartIdx,\n        colVisibleEndIdx = _a.colVisibleEndIdx,\n        colVisibleStartIdx = _a.colVisibleStartIdx,\n        onHitBottomBoundary = _a.onHitBottomBoundary,\n        onHitRightBoundary = _a.onHitRightBoundary,\n        onHitLeftBoundary = _a.onHitLeftBoundary,\n        onHitTopBoundary = _a.onHitTopBoundary;\n\n    var isCellAtBottomBoundary = function (cell) {\n      return cell.rowIdx >= rowVisibleEndIdx - SCROLL_CELL_BUFFER;\n    };\n\n    var isCellAtTopBoundary = function (cell) {\n      return cell.rowIdx !== 0 && cell.rowIdx <= rowVisibleStartIdx - 1;\n    };\n\n    var isCellAtRightBoundary = function (cell) {\n      return cell.idx !== 0 && cell.idx >= colVisibleEndIdx - 1;\n    };\n\n    var isCellAtLeftBoundary = function (cell) {\n      return cell.idx !== 0 && cell.idx <= colVisibleStartIdx + 1;\n    };\n\n    var ArrowDown = {\n      getNext: function (current) {\n        return __assign(__assign({}, current), {\n          rowIdx: current.rowIdx + 1\n        });\n      },\n      isCellAtBoundary: isCellAtBottomBoundary,\n      onHitBoundary: onHitBottomBoundary\n    };\n    var ArrowUp = {\n      getNext: function (current) {\n        return __assign(__assign({}, current), {\n          rowIdx: current.rowIdx - 1\n        });\n      },\n      isCellAtBoundary: isCellAtTopBoundary,\n      onHitBoundary: onHitTopBoundary\n    };\n    var ArrowRight = {\n      getNext: function (current) {\n        return __assign(__assign({}, current), {\n          idx: current.idx + 1\n        });\n      },\n      isCellAtBoundary: isCellAtRightBoundary,\n      onHitBoundary: function (next) {\n        onHitRightBoundary(next); // Selected cell can hit the bottom boundary when the cellNavigationMode is 'changeRow'\n\n        if (isCellAtBottomBoundary(next)) {\n          onHitBottomBoundary();\n        }\n      }\n    };\n    var ArrowLeft = {\n      getNext: function (current) {\n        return __assign(__assign({}, current), {\n          idx: current.idx - 1\n        });\n      },\n      isCellAtBoundary: isCellAtLeftBoundary,\n      onHitBoundary: function (next) {\n        onHitLeftBoundary(next); // Selected cell can hit the top boundary when the cellNavigationMode is 'changeRow'\n\n        if (isCellAtTopBoundary(next)) {\n          onHitTopBoundary();\n        }\n      }\n    };\n\n    if (e.keyCode === keyCodes.Tab) {\n      return e.shiftKey === true ? ArrowLeft : ArrowRight;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown':\n        return ArrowDown;\n\n      case 'ArrowUp':\n        return ArrowUp;\n\n      case 'ArrowRight':\n        return ArrowRight;\n\n      case 'ArrowLeft':\n        return ArrowLeft;\n\n      default:\n        return null;\n    }\n  };\n\n  InteractionMasks.prototype.changeCellFromEvent = function (e) {\n    e.preventDefault();\n    var isTab = e.keyCode === keyCodes.Tab;\n    var isShift = e.shiftKey;\n\n    if (isTab) {\n      var cellNavigationMode = this.props.cellNavigationMode === CellNavigationMode.NONE ? CellNavigationMode.CHANGE_ROW : this.props.cellNavigationMode;\n      this.changeCellFromKeyAction(e, cellNavigationMode);\n    } else if (isShift) {\n      this.changeSelectedRangeFromArrowKeyAction(e);\n    } else {\n      this.changeCellFromKeyAction(e, this.props.cellNavigationMode);\n    }\n  };\n\n  InteractionMasks.prototype.changeCellFromKeyAction = function (e, cellNavigationMode) {\n    var keyNavAction = this.getKeyNavActionFromEvent(e);\n\n    if (keyNavAction) {\n      var currentPosition = this.state.selectedPosition;\n      var next = this.getNextSelectedCellPositionForKeyNavAction(keyNavAction, currentPosition, cellNavigationMode);\n      this.checkIsAtGridBoundary(keyNavAction, next);\n      this.selectCell(next);\n    }\n  };\n\n  InteractionMasks.prototype.changeSelectedRangeFromArrowKeyAction = function (e) {\n    var _this = this;\n\n    var keyNavAction = this.getKeyNavActionFromEvent(e);\n\n    if (keyNavAction) {\n      var cellNavigationMode = this.props.cellNavigationMode;\n      var currentPosition = this.state.selectedRange.cursorCell || this.state.selectedPosition;\n      var next = this.getNextSelectedCellPositionForKeyNavAction(keyNavAction, currentPosition, cellNavigationMode);\n      this.checkIsAtGridBoundary(keyNavAction, next);\n      this.onSelectCellRangeUpdated(__assign({}, next), true, function () {\n        _this.onSelectCellRangeEnded();\n      });\n    }\n  };\n\n  InteractionMasks.prototype.getNextSelectedCellPositionForKeyNavAction = function (keyNavAction, currentPosition, cellNavigationMode) {\n    var getNext = keyNavAction.getNext;\n    var nextPosition = getNext(currentPosition);\n    var _a = this.props,\n        columns = _a.columns,\n        rowsCount = _a.rowsCount;\n    return getNextSelectedCellPosition({\n      columns: columns,\n      rowsCount: rowsCount,\n      cellNavigationMode: cellNavigationMode,\n      nextPosition: nextPosition\n    });\n  };\n\n  InteractionMasks.prototype.checkIsAtGridBoundary = function (keyNavAction, next) {\n    var isCellAtBoundary = keyNavAction.isCellAtBoundary,\n        onHitBoundary = keyNavAction.onHitBoundary;\n\n    var changeRowOrColumn = next.changeRowOrColumn,\n        nextPos = __rest(next, [\"changeRowOrColumn\"]);\n\n    if (isCellAtBoundary(nextPos) || changeRowOrColumn) {\n      onHitBoundary(nextPos);\n    }\n  };\n\n  InteractionMasks.prototype.isCellWithinBounds = function (_a) {\n    var idx = _a.idx,\n        rowIdx = _a.rowIdx;\n    var _b = this.props,\n        columns = _b.columns,\n        rowsCount = _b.rowsCount;\n    return rowIdx >= 0 && rowIdx < rowsCount && idx >= 0 && idx < columns.length;\n  };\n\n  InteractionMasks.prototype.isGridSelected = function () {\n    return this.isCellWithinBounds(this.state.selectedPosition);\n  };\n\n  InteractionMasks.prototype.isFocused = function () {\n    return document.activeElement === this.selectionMask.current;\n  };\n\n  InteractionMasks.prototype.isFocusedOnBody = function () {\n    return document.activeElement === document.body;\n  };\n\n  InteractionMasks.prototype.focus = function () {\n    if (this.selectionMask.current && !this.isFocused()) {\n      this.selectionMask.current.focus();\n    }\n  };\n\n  InteractionMasks.prototype.selectFirstCell = function () {\n    this.selectCell({\n      rowIdx: 0,\n      idx: 0\n    });\n  };\n\n  InteractionMasks.prototype.createSingleCellSelectedRange = function (cellPosition, isDragging) {\n    return {\n      topLeft: cellPosition,\n      bottomRight: cellPosition,\n      startCell: cellPosition,\n      cursorCell: cellPosition,\n      isDragging: isDragging\n    };\n  };\n\n  InteractionMasks.prototype.isDragEnabled = function () {\n    return this.isSelectedCellEditable();\n  };\n\n  InteractionMasks.prototype.renderSingleCellSelectView = function () {\n    return !this.state.isEditorEnabled && this.isGridSelected() && React.createElement(SelectionMask, __assign({}, this.getSelectedDimensions(this.state.selectedPosition, true), {\n      ref: this.selectionMask\n    }), this.isDragEnabled() && React.createElement(DragHandle, {\n      onDragStart: this.handleDragStart,\n      onDragEnd: this.handleDragEnd,\n      onDoubleClick: this.onDragHandleDoubleClick\n    }));\n  };\n\n  InteractionMasks.prototype.renderCellRangeSelectView = function () {\n    var _a = this.props,\n        columns = _a.columns,\n        rowHeight = _a.rowHeight;\n    return React.createElement(React.Fragment, null, React.createElement(SelectionRangeMask, __assign({}, getSelectedRangeDimensions({\n      selectedRange: this.state.selectedRange,\n      columns: columns,\n      rowHeight: rowHeight\n    }))), React.createElement(SelectionMask, __assign({}, this.getSelectedDimensions(this.state.selectedPosition, true), {\n      ref: this.selectionMask\n    })));\n  };\n\n  InteractionMasks.prototype.render = function () {\n    var _a = this.props,\n        rowGetter = _a.rowGetter,\n        contextMenu = _a.contextMenu,\n        getRowColumns = _a.getRowColumns,\n        scrollLeft = _a.scrollLeft,\n        scrollTop = _a.scrollTop;\n    var _b = this.state,\n        isEditorEnabled = _b.isEditorEnabled,\n        firstEditorKeyPress = _b.firstEditorKeyPress,\n        selectedPosition = _b.selectedPosition,\n        draggedPosition = _b.draggedPosition,\n        copiedPosition = _b.copiedPosition;\n    var rowData = rowGetter(selectedPosition.rowIdx);\n    var columns = getRowColumns(selectedPosition.rowIdx);\n    return React.createElement(\"div\", {\n      onKeyDown: this.onKeyDown,\n      onFocus: this.onFocus\n    }, copiedPosition && React.createElement(CopyMask, __assign({}, this.getSelectedDimensions(copiedPosition), {\n      ref: this.copyMask\n    })), draggedPosition && React.createElement(DragMask, {\n      draggedPosition: draggedPosition,\n      getSelectedDimensions: this.getSelectedDimensions\n    }), selectedRangeIsSingleCell(this.state.selectedRange) ? this.renderSingleCellSelectView() : this.renderCellRangeSelectView(), isEditorEnabled && React.createElement(EditorPortal, {\n      target: this.props.editorPortalTarget\n    }, React.createElement(EditorContainer, __assign({\n      firstEditorKeyPress: firstEditorKeyPress,\n      onCommit: this.onCommit,\n      onCommitCancel: this.onCommitCancel,\n      rowIdx: selectedPosition.rowIdx,\n      value: getSelectedCellValue({\n        selectedPosition: selectedPosition,\n        columns: columns,\n        rowGetter: rowGetter\n      }),\n      rowData: rowData,\n      column: columns[selectedPosition.idx],\n      scrollLeft: scrollLeft,\n      scrollTop: scrollTop\n    }, this.getSelectedDimensions(selectedPosition), this.state.editorPosition))), isElement(contextMenu) && cloneElement(contextMenu, __assign({}, selectedPosition)));\n  };\n\n  InteractionMasks.displayName = 'InteractionMasks';\n  return InteractionMasks;\n}(React.Component);\n\nexport default InteractionMasks;","map":{"version":3,"sources":["../../src/masks/InteractionMasks.tsx"],"names":[],"mappings":"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","sourcesContent":["import React, { cloneElement } from 'react';\nimport { isElement } from 'react-is';\n\n// Components\nimport SelectionMask from './SelectionMask';\nimport SelectionRangeMask from './SelectionRangeMask';\nimport CopyMask from './CopyMask';\nimport DragMask, { DraggedPosition } from './DragMask';\nimport DragHandle from './DragHandle';\nimport EditorContainer from '../common/editors/EditorContainer';\nimport EditorPortal from '../common/editors/EditorPortal';\n\n// Utils\nimport { isKeyPrintable, isCtrlKeyHeldDown } from '../common/utils/keyboardUtils';\nimport {\n  getSelectedDimensions,\n  getSelectedCellValue,\n  getSelectedRangeDimensions,\n  getNextSelectedCellPosition,\n  canExitGrid,\n  isSelectedCellEditable,\n  selectedRangeIsSingleCell,\n  NextSelectedCellPosition\n} from '../utils/SelectedCellUtils';\nimport { isFrozen } from '../ColumnUtils';\nimport keyCodes from '../KeyCodes';\n\n// Types\nimport { UpdateActions, CellNavigationMode, EventTypes } from '../common/enums';\nimport { CalculatedColumn, Position, SelectedRange, Dimension, InteractionMasksMetaData, CommitEvent } from '../common/types';\nimport { CanvasProps } from '../Canvas';\n\nconst SCROLL_CELL_BUFFER = 2;\n\ninterface NavAction {\n  getNext(current: Position): Position;\n  isCellAtBoundary(cell: Position): boolean;\n  onHitBoundary(next: Position): void;\n}\n\ntype SharedCanvasProps<R> = Pick<CanvasProps<R>,\n'rowGetter'\n| 'rowsCount'\n| 'rowHeight'\n| 'columns'\n| 'rowVisibleStartIdx'\n| 'rowVisibleEndIdx'\n| 'colVisibleStartIdx'\n| 'colVisibleEndIdx'\n| 'enableCellSelect'\n| 'enableCellAutoFocus'\n| 'cellNavigationMode'\n| 'eventBus'\n| 'contextMenu'\n| 'editorPortalTarget'\n>;\n\nexport interface InteractionMasksProps<R> extends SharedCanvasProps<R>, InteractionMasksMetaData<R> {\n  onHitTopBoundary(): void;\n  onHitBottomBoundary(): void;\n  onHitLeftBoundary(position: Position): void;\n  onHitRightBoundary(position: Position): void;\n  scrollLeft: number;\n  scrollTop: number;\n  getRowHeight(rowIdx: number): number;\n  getRowTop(rowIdx: number): number;\n  getRowColumns(rowIdx: number): CalculatedColumn<R>[];\n}\n\nexport interface InteractionMasksState {\n  selectedPosition: Position;\n  selectedRange: SelectedRange;\n  copiedPosition: Position & { value: unknown } | null;\n  draggedPosition: DraggedPosition | null;\n  editorPosition: { top: number; left: number } | null;\n  isEditorEnabled: boolean;\n  firstEditorKeyPress: string | null;\n}\n\nexport default class InteractionMasks<R> extends React.Component<InteractionMasksProps<R>, InteractionMasksState> {\n  static displayName = 'InteractionMasks';\n\n  readonly state: Readonly<InteractionMasksState> = {\n    selectedPosition: {\n      idx: -1,\n      rowIdx: -1\n    },\n    selectedRange: {\n      topLeft: {\n        idx: -1, rowIdx: -1\n      },\n      bottomRight: {\n        idx: -1, rowIdx: -1\n      },\n      startCell: null,\n      cursorCell: null,\n      isDragging: false\n    },\n    copiedPosition: null,\n    draggedPosition: null,\n    editorPosition: null,\n    isEditorEnabled: false,\n    firstEditorKeyPress: null\n  };\n\n  private readonly selectionMask = React.createRef<HTMLDivElement>();\n  private readonly copyMask = React.createRef<HTMLDivElement>();\n\n  private unsubscribeEventHandlers: Array<() => void> = [];\n\n  componentDidUpdate(prevProps: InteractionMasksProps<R>, prevState: InteractionMasksState) {\n    const { selectedPosition, isEditorEnabled } = this.state;\n    const { selectedPosition: prevSelectedPosition, isEditorEnabled: prevIsEditorEnabled } = prevState;\n    const isSelectedPositionChanged = selectedPosition !== prevSelectedPosition && (selectedPosition.rowIdx !== prevSelectedPosition.rowIdx || selectedPosition.idx !== prevSelectedPosition.idx);\n    const isEditorClosed = isEditorEnabled !== prevIsEditorEnabled && !isEditorEnabled;\n\n    if (isSelectedPositionChanged) {\n      // Call event handlers if selected cell has changed\n      const { onCellSelected, onCellDeSelected } = this.props;\n      if (onCellDeSelected && this.isCellWithinBounds(prevSelectedPosition)) {\n        onCellDeSelected({ ...prevSelectedPosition });\n      }\n\n      if (onCellSelected && this.isCellWithinBounds(selectedPosition)) {\n        onCellSelected({ ...selectedPosition });\n      }\n    }\n\n    if ((isSelectedPositionChanged && this.isCellWithinBounds(selectedPosition)) || isEditorClosed) {\n      this.focus();\n    }\n  }\n\n  componentDidMount() {\n    const { eventBus, enableCellAutoFocus } = this.props;\n\n    this.unsubscribeEventHandlers = [\n      eventBus.subscribe(EventTypes.SELECT_CELL, this.selectCell),\n      eventBus.subscribe(EventTypes.SELECT_START, this.onSelectCellRangeStarted),\n      eventBus.subscribe(EventTypes.SELECT_UPDATE, this.onSelectCellRangeUpdated),\n      eventBus.subscribe(EventTypes.SELECT_END, this.onSelectCellRangeEnded),\n      eventBus.subscribe(EventTypes.DRAG_ENTER, this.handleDragEnter)\n    ];\n\n    if (enableCellAutoFocus && this.isFocusedOnBody()) {\n      this.selectFirstCell();\n    }\n  }\n\n  componentWillUnmount() {\n    this.unsubscribeEventHandlers.forEach(h => h());\n  }\n\n  getEditorPosition() {\n    if (!this.selectionMask.current) return null;\n\n    const { editorPortalTarget } = this.props;\n    const { left: selectionMaskLeft, top: selectionMaskTop } = this.selectionMask.current.getBoundingClientRect();\n    if (editorPortalTarget === document.body) {\n      const { scrollLeft, scrollTop } = document.scrollingElement || document.documentElement;\n      return {\n        left: selectionMaskLeft + scrollLeft,\n        top: selectionMaskTop + scrollTop\n      };\n    }\n\n    const { left: portalTargetLeft, top: portalTargetTop } = editorPortalTarget.getBoundingClientRect();\n    const { scrollLeft, scrollTop } = editorPortalTarget;\n    return {\n      left: selectionMaskLeft - portalTargetLeft + scrollLeft,\n      top: selectionMaskTop - portalTargetTop + scrollTop\n    };\n  }\n\n  setMaskScollLeft(mask: HTMLDivElement | null, position: Position | null, scrollLeft: number): void {\n    if (!mask || !position) return;\n\n    const { idx, rowIdx } = position;\n    if (!(idx >= 0 && rowIdx >= 0)) return;\n\n    const column = this.props.columns[idx];\n    if (!isFrozen(column)) return;\n\n    const top = this.props.getRowTop(rowIdx);\n    const left = scrollLeft + column.left;\n    const transform = `translate(${left}px, ${top}px)`;\n    if (mask.style.transform !== transform) {\n      mask.style.transform = transform;\n    }\n  }\n\n  /**\n   * Sets the position of SelectionMask and CopyMask components when the canvas is scrolled\n   * This is only required on the frozen columns\n   */\n  setScrollLeft(scrollLeft: number): void {\n    this.setMaskScollLeft(this.selectionMask.current, this.state.selectedPosition, scrollLeft);\n    this.setMaskScollLeft(this.copyMask.current, this.state.copiedPosition, scrollLeft);\n  }\n\n  onKeyDown = (e: React.KeyboardEvent<HTMLDivElement>): void => {\n    if (isCtrlKeyHeldDown(e)) {\n      this.onPressKeyWithCtrl(e);\n    } else if (e.keyCode === keyCodes.Escape) {\n      this.onPressEscape();\n    } else if (e.keyCode === keyCodes.Tab) {\n      this.onPressTab(e);\n    } else if (this.isKeyboardNavigationEvent(e)) {\n      this.changeCellFromEvent(e);\n    } else if (isKeyPrintable(e.keyCode) || ([keyCodes.Backspace, keyCodes.Delete, keyCodes.Enter] as number[]).includes(e.keyCode)) {\n      this.openEditor(e);\n    }\n  };\n\n  isSelectedCellEditable(): boolean {\n    const { enableCellSelect, columns, rowGetter, onCheckCellIsEditable } = this.props;\n    const { selectedPosition } = this.state;\n    return isSelectedCellEditable<R>({ enableCellSelect, columns, rowGetter, selectedPosition, onCheckCellIsEditable });\n  }\n\n  openEditor = (event?: React.KeyboardEvent<HTMLDivElement>): void => {\n    if (this.isSelectedCellEditable() && !this.state.isEditorEnabled) {\n      this.setState({\n        isEditorEnabled: true,\n        firstEditorKeyPress: event ? event.key : null,\n        editorPosition: this.getEditorPosition()\n      });\n    }\n  };\n\n  closeEditor(): void {\n    this.setState({\n      isEditorEnabled: false,\n      firstEditorKeyPress: null,\n      editorPosition: null\n    });\n  }\n\n  onPressKeyWithCtrl({ keyCode }: React.KeyboardEvent<HTMLDivElement>): void {\n    if (this.copyPasteEnabled()) {\n      if (keyCode === keyCodes.c) {\n        const { columns, rowGetter } = this.props;\n        const { selectedPosition } = this.state;\n        const value = getSelectedCellValue({ selectedPosition, columns, rowGetter });\n        this.handleCopy(value);\n      } else if (keyCode === keyCodes.v) {\n        this.handlePaste();\n      }\n    }\n  }\n\n  onFocus = (): void => {\n    const { idx, rowIdx } = this.state.selectedPosition;\n    if (idx === -1 && rowIdx === -1) {\n      this.selectFirstCell();\n    }\n  };\n\n  onPressTab(e: React.KeyboardEvent<HTMLDivElement>): void {\n    const { cellNavigationMode, columns, rowsCount } = this.props;\n    const { selectedPosition, isEditorEnabled } = this.state;\n    // When there are no rows in the grid, we need to allow the browser to handle tab presses\n    if (rowsCount === 0) {\n      return;\n    }\n\n    // If we are in a position to leave the grid, stop editing but stay in that cell\n    if (canExitGrid(e, { cellNavigationMode, columns, rowsCount, selectedPosition })) {\n      if (isEditorEnabled) {\n        this.closeEditor();\n        return;\n      }\n\n      // Reset the selected position before exiting\n      this.setState({ selectedPosition: { idx: -1, rowIdx: -1 } });\n      return;\n    }\n\n    this.changeCellFromEvent(e);\n  }\n\n  onPressEscape(): void {\n    if (this.copyPasteEnabled()) {\n      this.handleCancelCopy();\n      this.closeEditor();\n    }\n  }\n\n  copyPasteEnabled(): boolean {\n    return this.props.onCellCopyPaste !== null && this.isSelectedCellEditable();\n  }\n\n  handleCopy(value: unknown): void {\n    const { rowIdx, idx } = this.state.selectedPosition;\n    this.setState({\n      copiedPosition: { rowIdx, idx, value }\n    });\n  }\n\n  handleCancelCopy(): void {\n    this.setState({ copiedPosition: null });\n  }\n\n  handlePaste(): void {\n    const { columns, onCellCopyPaste, onGridRowsUpdated } = this.props;\n    const { selectedPosition, copiedPosition } = this.state;\n    const { rowIdx: toRow } = selectedPosition;\n\n    if (copiedPosition === null) {\n      return;\n    }\n\n    const cellKey = columns[selectedPosition.idx].key;\n    const { rowIdx: fromRow, value } = copiedPosition;\n\n    if (onCellCopyPaste) {\n      onCellCopyPaste({\n        cellKey,\n        rowIdx: toRow,\n        fromRow,\n        toRow,\n        value\n      });\n    }\n\n    onGridRowsUpdated(cellKey, toRow, toRow, { [cellKey]: value }, UpdateActions.COPY_PASTE, fromRow);\n  }\n\n  isKeyboardNavigationEvent(e: React.KeyboardEvent<HTMLDivElement>): boolean {\n    return this.getKeyNavActionFromEvent(e) !== null;\n  }\n\n  getKeyNavActionFromEvent(e: React.KeyboardEvent<HTMLDivElement>): NavAction | null {\n    const { rowVisibleEndIdx, rowVisibleStartIdx, colVisibleEndIdx, colVisibleStartIdx, onHitBottomBoundary, onHitRightBoundary, onHitLeftBoundary, onHitTopBoundary } = this.props;\n    const isCellAtBottomBoundary = (cell: Position): boolean => cell.rowIdx >= rowVisibleEndIdx - SCROLL_CELL_BUFFER;\n    const isCellAtTopBoundary = (cell: Position): boolean => cell.rowIdx !== 0 && cell.rowIdx <= rowVisibleStartIdx - 1;\n    const isCellAtRightBoundary = (cell: Position): boolean => cell.idx !== 0 && cell.idx >= colVisibleEndIdx - 1;\n    const isCellAtLeftBoundary = (cell: Position): boolean => cell.idx !== 0 && cell.idx <= colVisibleStartIdx + 1;\n\n    const ArrowDown: NavAction = {\n      getNext: (current) => ({ ...current, rowIdx: current.rowIdx + 1 }),\n      isCellAtBoundary: isCellAtBottomBoundary,\n      onHitBoundary: onHitBottomBoundary\n    };\n    const ArrowUp: NavAction = {\n      getNext: (current) => ({ ...current, rowIdx: current.rowIdx - 1 }),\n      isCellAtBoundary: isCellAtTopBoundary,\n      onHitBoundary: onHitTopBoundary\n    };\n    const ArrowRight: NavAction = {\n      getNext: (current) => ({ ...current, idx: current.idx + 1 }),\n      isCellAtBoundary: isCellAtRightBoundary,\n      onHitBoundary(next) {\n        onHitRightBoundary(next);\n        // Selected cell can hit the bottom boundary when the cellNavigationMode is 'changeRow'\n        if (isCellAtBottomBoundary(next)) {\n          onHitBottomBoundary();\n        }\n      }\n    };\n    const ArrowLeft: NavAction = {\n      getNext: (current) => ({ ...current, idx: current.idx - 1 }),\n      isCellAtBoundary: isCellAtLeftBoundary,\n      onHitBoundary(next) {\n        onHitLeftBoundary(next);\n        // Selected cell can hit the top boundary when the cellNavigationMode is 'changeRow'\n        if (isCellAtTopBoundary(next)) {\n          onHitTopBoundary();\n        }\n      }\n    };\n\n    if (e.keyCode === keyCodes.Tab) {\n      return e.shiftKey === true ? ArrowLeft : ArrowRight;\n    }\n\n    switch (e.key) {\n      case 'ArrowDown': return ArrowDown;\n      case 'ArrowUp': return ArrowUp;\n      case 'ArrowRight': return ArrowRight;\n      case 'ArrowLeft': return ArrowLeft;\n      default: return null;\n    }\n  }\n\n  changeCellFromEvent(e: React.KeyboardEvent<HTMLDivElement>): void {\n    e.preventDefault();\n    const isTab = e.keyCode === keyCodes.Tab;\n    const isShift = e.shiftKey;\n\n    if (isTab) {\n      const cellNavigationMode = this.props.cellNavigationMode === CellNavigationMode.NONE\n        ? CellNavigationMode.CHANGE_ROW\n        : this.props.cellNavigationMode;\n      this.changeCellFromKeyAction(e, cellNavigationMode);\n    } else if (isShift) {\n      this.changeSelectedRangeFromArrowKeyAction(e);\n    } else {\n      this.changeCellFromKeyAction(e, this.props.cellNavigationMode);\n    }\n  }\n\n  changeCellFromKeyAction(e: React.KeyboardEvent<HTMLDivElement>, cellNavigationMode: CellNavigationMode): void {\n    const keyNavAction = this.getKeyNavActionFromEvent(e);\n    if (keyNavAction) {\n      const currentPosition = this.state.selectedPosition;\n      const next = this.getNextSelectedCellPositionForKeyNavAction(keyNavAction, currentPosition, cellNavigationMode);\n      this.checkIsAtGridBoundary(keyNavAction, next);\n      this.selectCell(next);\n    }\n  }\n\n  changeSelectedRangeFromArrowKeyAction(e: React.KeyboardEvent<HTMLDivElement>): void {\n    const keyNavAction = this.getKeyNavActionFromEvent(e);\n    if (keyNavAction) {\n      const { cellNavigationMode } = this.props;\n      const currentPosition = this.state.selectedRange.cursorCell || this.state.selectedPosition;\n      const next = this.getNextSelectedCellPositionForKeyNavAction(keyNavAction, currentPosition, cellNavigationMode);\n      this.checkIsAtGridBoundary(keyNavAction, next);\n      this.onSelectCellRangeUpdated({ ...next }, true, () => { this.onSelectCellRangeEnded(); });\n    }\n  }\n\n  getNextSelectedCellPositionForKeyNavAction(keyNavAction: NavAction, currentPosition: Position, cellNavigationMode: CellNavigationMode): NextSelectedCellPosition {\n    const { getNext } = keyNavAction;\n    const nextPosition = getNext(currentPosition);\n    const { columns, rowsCount } = this.props;\n    return getNextSelectedCellPosition({\n      columns,\n      rowsCount,\n      cellNavigationMode,\n      nextPosition\n    });\n  }\n\n  checkIsAtGridBoundary(keyNavAction: NavAction, next: NextSelectedCellPosition): void {\n    const { isCellAtBoundary, onHitBoundary } = keyNavAction;\n    const { changeRowOrColumn, ...nextPos } = next;\n    if (isCellAtBoundary(nextPos) || changeRowOrColumn) {\n      onHitBoundary(nextPos);\n    }\n  }\n\n  isCellWithinBounds({ idx, rowIdx }: Position): boolean {\n    const { columns, rowsCount } = this.props;\n    return rowIdx >= 0 && rowIdx < rowsCount && idx >= 0 && idx < columns.length;\n  }\n\n  isGridSelected(): boolean {\n    return this.isCellWithinBounds(this.state.selectedPosition);\n  }\n\n  isFocused(): boolean {\n    return document.activeElement === this.selectionMask.current;\n  }\n\n  isFocusedOnBody(): boolean {\n    return document.activeElement === document.body;\n  }\n\n  focus(): void {\n    if (this.selectionMask.current && !this.isFocused()) {\n      this.selectionMask.current.focus();\n    }\n  }\n\n  selectFirstCell(): void {\n    this.selectCell({ rowIdx: 0, idx: 0 });\n  }\n\n  selectCell = (cell: Position, openEditor?: boolean): void => {\n    const callback = openEditor ? this.openEditor : undefined;\n    // Close the editor to commit any pending changes\n    if (this.state.isEditorEnabled) {\n      this.closeEditor();\n    }\n    this.setState(() => {\n      if (!this.isCellWithinBounds(cell)) return null;\n\n      return {\n        selectedPosition: cell,\n        selectedRange: {\n          topLeft: cell,\n          bottomRight: cell,\n          startCell: cell,\n          cursorCell: cell,\n          isDragging: false\n        }\n      };\n    }, callback);\n  };\n\n  createSingleCellSelectedRange(cellPosition: Position, isDragging: boolean): SelectedRange {\n    return {\n      topLeft: cellPosition,\n      bottomRight: cellPosition,\n      startCell: cellPosition,\n      cursorCell: cellPosition,\n      isDragging\n    };\n  }\n\n  onSelectCellRangeStarted = (selectedPosition: Position): void => {\n    this.setState({\n      selectedRange: this.createSingleCellSelectedRange(selectedPosition, true),\n      selectedPosition\n    }, () => {\n      if (this.props.onCellRangeSelectionStarted) {\n        this.props.onCellRangeSelectionStarted(this.state.selectedRange);\n      }\n    });\n  };\n\n  onSelectCellRangeUpdated = (cellPosition: Position, isFromKeyboard?: boolean, callback?: () => void): void => {\n    if (!this.state.selectedRange.isDragging && !isFromKeyboard || !this.isCellWithinBounds(cellPosition)) {\n      return;\n    }\n\n    const startCell = this.state.selectedRange.startCell || this.state.selectedPosition;\n    const colIdxs = [startCell.idx, cellPosition.idx].sort((a, b) => a - b);\n    const rowIdxs = [startCell.rowIdx, cellPosition.rowIdx].sort((a, b) => a - b);\n    const topLeft: Position = { idx: colIdxs[0], rowIdx: rowIdxs[0] };\n    const bottomRight: Position = { idx: colIdxs[1], rowIdx: rowIdxs[1] };\n\n    const selectedRange: SelectedRange = {\n      ...this.state.selectedRange,\n      // default the startCell to the selected cell, in case we've just started via keyboard\n      startCell: this.state.selectedRange.startCell || this.state.selectedPosition,\n      // assign the new state - the bounds of the range, and the new cursor cell\n      topLeft,\n      bottomRight,\n      cursorCell: cellPosition\n    };\n\n    this.setState({\n      selectedRange\n    }, () => {\n      if (this.props.onCellRangeSelectionUpdated) {\n        this.props.onCellRangeSelectionUpdated(this.state.selectedRange);\n      }\n      if (callback) {\n        callback();\n      }\n    });\n  };\n\n  onSelectCellRangeEnded = (): void => {\n    const selectedRange = { ...this.state.selectedRange, isDragging: false };\n    this.setState({ selectedRange }, () => {\n      if (this.props.onCellRangeSelectionCompleted) {\n        this.props.onCellRangeSelectionCompleted(this.state.selectedRange);\n      }\n\n      // Focus the InteractionMasks, so it can receive keyboard events\n      this.focus();\n    });\n  };\n\n  isDragEnabled(): boolean {\n    return this.isSelectedCellEditable();\n  }\n\n  handleDragStart = (e: React.DragEvent<HTMLDivElement>): void => {\n    const { selectedPosition } = this.state;\n    // To prevent dragging down/up when reordering rows. (TODO: is this required)\n    if (selectedPosition.idx > -1) {\n      e.dataTransfer.effectAllowed = 'copy';\n      // Setting data is required to make an element draggable in FF\n      const transferData = JSON.stringify(selectedPosition);\n      try {\n        e.dataTransfer.setData('text/plain', transferData);\n      } catch (ex) {\n        // IE only supports 'text' and 'URL' for the 'type' argument\n        e.dataTransfer.setData('text', transferData);\n      }\n      this.setState({\n        draggedPosition: {\n          ...selectedPosition,\n          overRowIdx: selectedPosition.rowIdx\n        }\n      });\n    }\n  };\n\n  handleDragEnter = (overRowIdx: number): void => {\n    this.setState(({ draggedPosition }) => {\n      if (draggedPosition) {\n        return { draggedPosition: { ...draggedPosition, overRowIdx } };\n      }\n      return null;\n    });\n  };\n\n  handleDragEnd = () => {\n    const { draggedPosition } = this.state;\n    if (draggedPosition === null) return;\n\n    const { rowIdx, overRowIdx } = draggedPosition;\n    const { columns, onGridRowsUpdated, rowGetter } = this.props;\n    const column = columns[draggedPosition.idx];\n    const value = getSelectedCellValue({ selectedPosition: draggedPosition, columns, rowGetter });\n    const cellKey = column.key;\n    const fromRow = rowIdx < overRowIdx ? rowIdx : overRowIdx;\n    const toRow = rowIdx > overRowIdx ? rowIdx : overRowIdx;\n\n    onGridRowsUpdated(cellKey, fromRow, toRow, { [cellKey]: value }, UpdateActions.CELL_DRAG);\n\n    this.setState({\n      draggedPosition: null\n    });\n  };\n\n  onDragHandleDoubleClick = (): void => {\n    const { onDragHandleDoubleClick, rowGetter } = this.props;\n    const { selectedPosition } = this.state;\n    const { idx, rowIdx } = selectedPosition;\n    const rowData = rowGetter(selectedPosition.rowIdx);\n    onDragHandleDoubleClick({ idx, rowIdx, rowData });\n  };\n\n  onCommit = (args: CommitEvent<R>): void => {\n    this.props.onCommit(args);\n    this.closeEditor();\n  };\n\n  onCommitCancel = (): void => {\n    this.closeEditor();\n  };\n\n  getSelectedDimensions = (selectedPosition: Position, useGridColumns?: boolean): Dimension => {\n    const { scrollLeft, getRowHeight, getRowTop, getRowColumns, columns: gridColumns } = this.props;\n    const columns = useGridColumns ? gridColumns : getRowColumns(selectedPosition.rowIdx);\n    const top = getRowTop(selectedPosition.rowIdx);\n    const rowHeight = getRowHeight(selectedPosition.rowIdx);\n    const dimension = getSelectedDimensions({ selectedPosition, columns, scrollLeft, rowHeight });\n    dimension.top = top;\n    return dimension;\n  };\n\n  renderSingleCellSelectView() {\n    return (\n      !this.state.isEditorEnabled && this.isGridSelected() && (\n        <SelectionMask\n          {...this.getSelectedDimensions(this.state.selectedPosition, true)}\n          ref={this.selectionMask}\n        >\n          {this.isDragEnabled() && (\n            <DragHandle\n              onDragStart={this.handleDragStart}\n              onDragEnd={this.handleDragEnd}\n              onDoubleClick={this.onDragHandleDoubleClick}\n            />\n          )}\n        </SelectionMask>\n      )\n    );\n  }\n\n  renderCellRangeSelectView() {\n    const { columns, rowHeight } = this.props;\n    return (\n      <>\n        <SelectionRangeMask\n          {...getSelectedRangeDimensions({ selectedRange: this.state.selectedRange, columns, rowHeight })}\n        />\n        <SelectionMask\n          {...this.getSelectedDimensions(this.state.selectedPosition, true)}\n          ref={this.selectionMask}\n        />\n      </>\n    );\n  }\n\n  render() {\n    const { rowGetter, contextMenu, getRowColumns, scrollLeft, scrollTop } = this.props;\n    const { isEditorEnabled, firstEditorKeyPress, selectedPosition, draggedPosition, copiedPosition } = this.state;\n    const rowData = rowGetter(selectedPosition.rowIdx);\n    const columns = getRowColumns(selectedPosition.rowIdx);\n    return (\n      <div\n        onKeyDown={this.onKeyDown}\n        onFocus={this.onFocus}\n      >\n        {copiedPosition && (\n          <CopyMask\n            {...this.getSelectedDimensions(copiedPosition)}\n            ref={this.copyMask}\n          />\n        )}\n        {draggedPosition && (\n          <DragMask\n            draggedPosition={draggedPosition}\n            getSelectedDimensions={this.getSelectedDimensions}\n          />\n        )}\n        {selectedRangeIsSingleCell(this.state.selectedRange)\n          ? this.renderSingleCellSelectView()\n          : this.renderCellRangeSelectView()\n        }\n        {isEditorEnabled && (\n          <EditorPortal target={this.props.editorPortalTarget}>\n            <EditorContainer<R>\n              firstEditorKeyPress={firstEditorKeyPress}\n              onCommit={this.onCommit}\n              onCommitCancel={this.onCommitCancel}\n              rowIdx={selectedPosition.rowIdx}\n              value={getSelectedCellValue({ selectedPosition, columns, rowGetter })!}\n              rowData={rowData}\n              column={columns[selectedPosition.idx]}\n              scrollLeft={scrollLeft}\n              scrollTop={scrollTop}\n              {...this.getSelectedDimensions(selectedPosition)}\n              {...this.state.editorPosition}\n            />\n          </EditorPortal>\n        )}\n        {isElement(contextMenu) && cloneElement(contextMenu, { ...selectedPosition })}\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}