{"ast":null,"code":"import { isFrozen } from '../ColumnUtils';\nimport { SCROLL_DIRECTION } from '../common/enums';\nexport var OVERSCAN_ROWS = 2;\nvar min = Math.min,\n    max = Math.max,\n    ceil = Math.ceil,\n    round = Math.round;\nexport function getGridState(props) {\n  var totalNumberColumns = props.columnMetrics.columns.length;\n  var canvasHeight = props.minHeight - props.rowOffsetHeight;\n  var renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);\n  var rowOverscanEndIdx = min(props.rowsCount, renderedRowsCount * 2);\n  return {\n    rowOverscanStartIdx: 0,\n    rowOverscanEndIdx: rowOverscanEndIdx,\n    rowVisibleStartIdx: 0,\n    rowVisibleEndIdx: renderedRowsCount,\n    height: canvasHeight,\n    scrollTop: 0,\n    scrollLeft: 0,\n    colVisibleStartIdx: 0,\n    colVisibleEndIdx: totalNumberColumns,\n    colOverscanStartIdx: 0,\n    colOverscanEndIdx: totalNumberColumns,\n    isScrolling: false,\n    lastFrozenColumnIndex: 0\n  };\n}\nexport function findLastFrozenColumnIndex(columns) {\n  return columns.findIndex(function (c) {\n    return isFrozen(c);\n  });\n}\n\nfunction getTotalFrozenColumnWidth(columns) {\n  var lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n\n  var lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nfunction getColumnCountForWidth(columns, initialWidth, colVisibleStartIdx) {\n  var width = initialWidth;\n  var count = 0;\n  columns.forEach(function (column, idx) {\n    if (idx >= colVisibleStartIdx) {\n      width -= column.width;\n\n      if (width >= 0) {\n        count++;\n      }\n    }\n  });\n  return count;\n}\n\nexport function getNonFrozenVisibleColStartIdx(columns, scrollLeft) {\n  var remainingScroll = scrollLeft;\n  var lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  var nonFrozenColumns = columns.slice(lastFrozenColumnIndex + 1);\n  var columnIndex = lastFrozenColumnIndex;\n\n  while (remainingScroll >= 0 && columnIndex < nonFrozenColumns.length) {\n    columnIndex++;\n    var column = columns[columnIndex];\n    remainingScroll -= column ? column.width : 0;\n  }\n\n  return max(columnIndex, 0);\n}\nexport function getNonFrozenRenderedColumnCount(columnMetrics, viewportDomWidth, scrollLeft) {\n  var columns = columnMetrics.columns,\n      totalColumnWidth = columnMetrics.totalColumnWidth;\n\n  if (columns.length === 0) {\n    return 0;\n  }\n\n  var colVisibleStartIdx = getNonFrozenVisibleColStartIdx(columns, scrollLeft);\n  var totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns);\n  var viewportWidth = viewportDomWidth > 0 ? viewportDomWidth : totalColumnWidth;\n  var firstColumn = columns[colVisibleStartIdx]; // calculate the portion width of first column hidden behind frozen columns\n\n  var scrolledFrozenWidth = totalFrozenColumnWidth + scrollLeft;\n  var firstColumnHiddenWidth = scrolledFrozenWidth > firstColumn.left ? scrolledFrozenWidth - firstColumn.left : 0;\n  var initialWidth = viewportWidth - totalFrozenColumnWidth + firstColumnHiddenWidth;\n  return getColumnCountForWidth(columns, initialWidth, colVisibleStartIdx);\n}\nexport function getVisibleBoundaries(gridHeight, rowHeight, scrollTop, rowsCount) {\n  var renderedRowsCount = ceil(gridHeight / rowHeight);\n  var rowVisibleStartIdx = max(0, round(scrollTop / rowHeight));\n  var rowVisibleEndIdx = min(rowVisibleStartIdx + renderedRowsCount, rowsCount);\n  return {\n    rowVisibleStartIdx: rowVisibleStartIdx,\n    rowVisibleEndIdx: rowVisibleEndIdx\n  };\n}\nexport function getScrollDirection(lastScroll, scrollTop, scrollLeft) {\n  if (scrollTop !== lastScroll.scrollTop && lastScroll.scrollTop !== undefined) {\n    return scrollTop - lastScroll.scrollTop >= 0 ? SCROLL_DIRECTION.DOWN : SCROLL_DIRECTION.UP;\n  }\n\n  if (scrollLeft !== lastScroll.scrollLeft && lastScroll.scrollLeft !== undefined) {\n    return scrollLeft - lastScroll.scrollLeft >= 0 ? SCROLL_DIRECTION.RIGHT : SCROLL_DIRECTION.LEFT;\n  }\n\n  return SCROLL_DIRECTION.NONE;\n}\nexport function getRowOverscanStartIdx(scrollDirection, rowVisibleStartIdx) {\n  return scrollDirection === SCROLL_DIRECTION.UP ? max(0, rowVisibleStartIdx - OVERSCAN_ROWS) : max(0, rowVisibleStartIdx);\n}\nexport function getRowOverscanEndIdx(scrollDirection, rowVisibleEndIdx, rowsCount) {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN) {\n    var overscanBoundaryIdx = rowVisibleEndIdx + OVERSCAN_ROWS;\n    return min(overscanBoundaryIdx, rowsCount);\n  }\n\n  return rowVisibleEndIdx;\n}\nexport function getColOverscanStartIdx(scrollDirection, colVisibleStartIdx, lastFrozenColumnIdx) {\n  if (scrollDirection === SCROLL_DIRECTION.LEFT || scrollDirection === SCROLL_DIRECTION.RIGHT) {\n    return lastFrozenColumnIdx > -1 ? lastFrozenColumnIdx + 1 : 0;\n  }\n\n  return colVisibleStartIdx;\n}\nexport function getColOverscanEndIdx(scrollDirection, colVisibleEndIdx, totalNumberColumns) {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN || scrollDirection === SCROLL_DIRECTION.UP) {\n    return colVisibleEndIdx;\n  }\n\n  return totalNumberColumns;\n}","map":{"version":3,"sources":["../../src/utils/viewportUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import { isFrozen } from '../ColumnUtils';\nimport { SCROLL_DIRECTION } from '../common/enums';\nimport { CalculatedColumn, ColumnMetrics } from '../common/types';\n\nexport const OVERSCAN_ROWS = 2;\n\nconst { min, max, ceil, round } = Math;\n\nexport function getGridState<R>(props: { columnMetrics: ColumnMetrics<R>; rowsCount: number; minHeight: number; rowHeight: number; rowOffsetHeight: number }) {\n  const totalNumberColumns = props.columnMetrics.columns.length;\n  const canvasHeight = props.minHeight - props.rowOffsetHeight;\n  const renderedRowsCount = ceil((props.minHeight - props.rowHeight) / props.rowHeight);\n  const rowOverscanEndIdx = min(props.rowsCount, renderedRowsCount * 2);\n\n  return {\n    rowOverscanStartIdx: 0,\n    rowOverscanEndIdx,\n    rowVisibleStartIdx: 0,\n    rowVisibleEndIdx: renderedRowsCount,\n    height: canvasHeight,\n    scrollTop: 0,\n    scrollLeft: 0,\n    colVisibleStartIdx: 0,\n    colVisibleEndIdx: totalNumberColumns,\n    colOverscanStartIdx: 0,\n    colOverscanEndIdx: totalNumberColumns,\n    isScrolling: false,\n    lastFrozenColumnIndex: 0\n  };\n}\n\nexport function findLastFrozenColumnIndex<R>(columns: CalculatedColumn<R>[]): number {\n  return columns.findIndex(c => isFrozen(c));\n}\n\nfunction getTotalFrozenColumnWidth<R>(columns: CalculatedColumn<R>[]): number {\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  if (lastFrozenColumnIndex === -1) {\n    return 0;\n  }\n  const lastFrozenColumn = columns[lastFrozenColumnIndex];\n  return lastFrozenColumn.left + lastFrozenColumn.width;\n}\n\nfunction getColumnCountForWidth<R>(columns: CalculatedColumn<R>[], initialWidth: number, colVisibleStartIdx: number): number {\n  let width = initialWidth;\n  let count = 0;\n\n  columns.forEach((column, idx) => {\n    if (idx! >= colVisibleStartIdx) {\n      width -= column.width;\n      if (width >= 0) {\n        count++;\n      }\n    }\n  });\n\n  return count;\n}\n\nexport function getNonFrozenVisibleColStartIdx<R>(columns: CalculatedColumn<R>[], scrollLeft: number): number {\n  let remainingScroll = scrollLeft;\n  const lastFrozenColumnIndex = findLastFrozenColumnIndex(columns);\n  const nonFrozenColumns = columns.slice(lastFrozenColumnIndex + 1);\n  let columnIndex = lastFrozenColumnIndex;\n  while (remainingScroll >= 0 && columnIndex < nonFrozenColumns.length) {\n    columnIndex++;\n    const column = columns[columnIndex];\n    remainingScroll -= column ? column.width : 0;\n  }\n  return max(columnIndex, 0);\n}\n\nexport function getNonFrozenRenderedColumnCount<R>(columnMetrics: ColumnMetrics<R>, viewportDomWidth: number, scrollLeft: number): number {\n  const { columns, totalColumnWidth } = columnMetrics;\n  if (columns.length === 0) {\n    return 0;\n  }\n  const colVisibleStartIdx = getNonFrozenVisibleColStartIdx(columns, scrollLeft);\n  const totalFrozenColumnWidth = getTotalFrozenColumnWidth(columns);\n  const viewportWidth = viewportDomWidth > 0 ? viewportDomWidth : totalColumnWidth;\n  const firstColumn = columns[colVisibleStartIdx];\n  // calculate the portion width of first column hidden behind frozen columns\n  const scrolledFrozenWidth = totalFrozenColumnWidth + scrollLeft;\n  const firstColumnHiddenWidth = scrolledFrozenWidth > firstColumn.left ? scrolledFrozenWidth - firstColumn.left : 0;\n  const initialWidth = viewportWidth - totalFrozenColumnWidth + firstColumnHiddenWidth;\n  return getColumnCountForWidth(columns, initialWidth, colVisibleStartIdx);\n}\n\nexport interface VisibleBoundaries {\n  rowVisibleStartIdx: number;\n  rowVisibleEndIdx: number;\n}\n\nexport function getVisibleBoundaries(gridHeight: number, rowHeight: number, scrollTop: number, rowsCount: number): VisibleBoundaries {\n  const renderedRowsCount = ceil(gridHeight / rowHeight);\n  const rowVisibleStartIdx = max(0, round(scrollTop / rowHeight));\n  const rowVisibleEndIdx = min(rowVisibleStartIdx + renderedRowsCount, rowsCount);\n  return { rowVisibleStartIdx, rowVisibleEndIdx };\n}\n\ninterface ScrollState {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n\nexport function getScrollDirection(lastScroll: ScrollState, scrollTop: number, scrollLeft: number): SCROLL_DIRECTION {\n  if (scrollTop !== lastScroll.scrollTop && lastScroll.scrollTop !== undefined) {\n    return scrollTop - lastScroll.scrollTop >= 0 ? SCROLL_DIRECTION.DOWN : SCROLL_DIRECTION.UP;\n  }\n  if (scrollLeft !== lastScroll.scrollLeft && lastScroll.scrollLeft !== undefined) {\n    return scrollLeft - lastScroll.scrollLeft >= 0 ? SCROLL_DIRECTION.RIGHT : SCROLL_DIRECTION.LEFT;\n  }\n  return SCROLL_DIRECTION.NONE;\n}\n\nexport function getRowOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleStartIdx: number): number {\n  return scrollDirection === SCROLL_DIRECTION.UP ? max(0, rowVisibleStartIdx - OVERSCAN_ROWS) : max(0, rowVisibleStartIdx);\n}\n\nexport function getRowOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, rowVisibleEndIdx: number, rowsCount: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN) {\n    const overscanBoundaryIdx = rowVisibleEndIdx + OVERSCAN_ROWS;\n    return min(overscanBoundaryIdx, rowsCount);\n  }\n  return rowVisibleEndIdx;\n}\n\nexport function getColOverscanStartIdx(scrollDirection: SCROLL_DIRECTION, colVisibleStartIdx: number, lastFrozenColumnIdx: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.LEFT || scrollDirection === SCROLL_DIRECTION.RIGHT) {\n    return lastFrozenColumnIdx > -1 ? lastFrozenColumnIdx + 1 : 0;\n  }\n  return colVisibleStartIdx;\n}\n\nexport function getColOverscanEndIdx(scrollDirection: SCROLL_DIRECTION, colVisibleEndIdx: number, totalNumberColumns: number): number {\n  if (scrollDirection === SCROLL_DIRECTION.DOWN || scrollDirection === SCROLL_DIRECTION.UP) {\n    return colVisibleEndIdx;\n  }\n  return totalNumberColumns;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}