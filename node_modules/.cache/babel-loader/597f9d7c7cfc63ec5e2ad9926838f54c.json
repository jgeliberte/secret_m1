{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport React from 'react';\nimport { isElement } from 'react-is';\nimport Row from './Row';\nimport RowsContainerDefault from './RowsContainer';\nimport RowGroup from './RowGroup';\nimport { InteractionMasks } from './masks';\nimport * as rowUtils from './RowUtils';\nimport { getColumnScrollPosition } from './utils/canvasUtils';\nimport { EventTypes } from './common/enums';\n\nvar Canvas =\n/** @class */\nfunction (_super) {\n  __extends(Canvas, _super);\n\n  function Canvas() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.canvas = React.createRef();\n    _this.interactionMasks = React.createRef();\n    _this.rows = new Map();\n    _this._scroll = {\n      scrollTop: 0,\n      scrollLeft: 0\n    };\n\n    _this.handleScroll = function (e) {\n      var _a = e.currentTarget,\n          scrollLeft = _a.scrollLeft,\n          scrollTop = _a.scrollTop;\n      _this._scroll = {\n        scrollTop: scrollTop,\n        scrollLeft: scrollLeft\n      };\n\n      if (_this.props.onScroll) {\n        _this.props.onScroll(_this._scroll);\n      }\n    };\n\n    _this.onHitBottomCanvas = function () {\n      var current = _this.canvas.current;\n\n      if (current) {\n        current.scrollTop += _this.props.rowHeight + _this.getClientScrollTopOffset(current);\n      }\n    };\n\n    _this.onHitTopCanvas = function () {\n      var current = _this.canvas.current;\n\n      if (current) {\n        current.scrollTop -= _this.props.rowHeight - _this.getClientScrollTopOffset(current);\n      }\n    };\n\n    _this.handleHitColummBoundary = function (_a) {\n      var idx = _a.idx;\n\n      _this.scrollToColumn(idx);\n    };\n\n    _this.scrollToColumn = function (idx) {\n      var current = _this.canvas.current;\n      if (!current) return;\n      var scrollLeft = current.scrollLeft,\n          clientWidth = current.clientWidth;\n      var newScrollLeft = getColumnScrollPosition(_this.props.columns, idx, scrollLeft, clientWidth);\n\n      if (newScrollLeft !== 0) {\n        current.scrollLeft = scrollLeft + newScrollLeft;\n      }\n    };\n\n    _this.getRowByRef = function (i) {\n      // check if wrapped with React DND drop target\n      if (!_this.rows.has(i)) return;\n\n      var row = _this.rows.get(i);\n\n      var wrappedRow = row.getDecoratedComponentInstance ? row.getDecoratedComponentInstance(i) : null;\n      return wrappedRow ? wrappedRow.row : row;\n    };\n\n    _this.getRowTop = function (rowIdx) {\n      var row = _this.getRowByRef(rowIdx);\n\n      if (row && row.getRowTop) {\n        return row.getRowTop();\n      }\n\n      return _this.props.rowHeight * rowIdx;\n    };\n\n    _this.getRowHeight = function (rowIdx) {\n      var row = _this.getRowByRef(rowIdx);\n\n      if (row && row.getRowHeight) {\n        return row.getRowHeight();\n      }\n\n      return _this.props.rowHeight;\n    };\n\n    _this.getRowColumns = function (rowIdx) {\n      var row = _this.getRowByRef(rowIdx);\n\n      return row && row.props ? row.props.columns : _this.props.columns;\n    };\n\n    return _this;\n  }\n\n  Canvas.prototype.componentDidMount = function () {\n    this.unsubscribeScrollToColumn = this.props.eventBus.subscribe(EventTypes.SCROLL_TO_COLUMN, this.scrollToColumn);\n  };\n\n  Canvas.prototype.componentWillUnmount = function () {\n    this.unsubscribeScrollToColumn();\n  };\n\n  Canvas.prototype.componentDidUpdate = function (prevProps) {\n    var scrollToRowIndex = this.props.scrollToRowIndex;\n\n    if (scrollToRowIndex && prevProps.scrollToRowIndex !== scrollToRowIndex) {\n      this.scrollToRow(scrollToRowIndex);\n    }\n  };\n\n  Canvas.prototype.scrollToRow = function (scrollToRowIndex) {\n    var current = this.canvas.current;\n    if (!current) return;\n    var _a = this.props,\n        rowHeight = _a.rowHeight,\n        rowsCount = _a.rowsCount,\n        height = _a.height;\n    current.scrollTop = Math.min(scrollToRowIndex * rowHeight, rowsCount * rowHeight - height);\n  };\n\n  Canvas.prototype.getRows = function (rowOverscanStartIdx, rowOverscanEndIdx) {\n    var rows = [];\n    var i = rowOverscanStartIdx;\n\n    while (i < rowOverscanEndIdx) {\n      var row = this.props.rowGetter(i);\n      var subRowDetails = void 0;\n\n      if (this.props.getSubRowDetails) {\n        subRowDetails = this.props.getSubRowDetails(row);\n      }\n\n      rows.push({\n        row: row,\n        subRowDetails: subRowDetails\n      });\n      i++;\n    }\n\n    return rows;\n  };\n\n  Canvas.prototype.getScroll = function () {\n    var _a = this.canvas.current,\n        scrollTop = _a.scrollTop,\n        scrollLeft = _a.scrollLeft;\n    return {\n      scrollTop: scrollTop,\n      scrollLeft: scrollLeft\n    };\n  };\n\n  Canvas.prototype.getClientScrollTopOffset = function (node) {\n    var rowHeight = this.props.rowHeight;\n    var scrollVariation = node.scrollTop % rowHeight;\n    return scrollVariation > 0 ? rowHeight - scrollVariation : 0;\n  };\n\n  Canvas.prototype.isRowSelected = function (idx, row) {\n    var _this = this; // Use selectedRows if set\n\n\n    if (this.props.selectedRows) {\n      var selectedRow = this.props.selectedRows.find(function (r) {\n        var rowKeyValue = rowUtils.get(row, _this.props.rowKey);\n        return r[_this.props.rowKey] === rowKeyValue;\n      });\n      return !!(selectedRow && selectedRow.isSelected);\n    } // Else use new rowSelection props\n\n\n    if (this.props.rowSelection) {\n      var _a = this.props.rowSelection,\n          keys = _a.keys,\n          indexes = _a.indexes,\n          isSelectedKey = _a.isSelectedKey;\n      return rowUtils.isRowSelected(keys, indexes, isSelectedKey, row, idx);\n    }\n\n    return false;\n  };\n\n  Canvas.prototype.setScrollLeft = function (scrollLeft) {\n    var _this = this;\n\n    var current = this.interactionMasks.current;\n\n    if (current) {\n      current.setScrollLeft(scrollLeft);\n    }\n\n    this.rows.forEach(function (r, idx) {\n      var row = _this.getRowByRef(idx);\n\n      if (row && row.setScrollLeft) {\n        row.setScrollLeft(scrollLeft);\n      }\n    });\n  };\n\n  Canvas.prototype.renderCustomRowRenderer = function (props) {\n    var ref = props.ref,\n        otherProps = __rest(props, [\"ref\"]);\n\n    var CustomRowRenderer = this.props.rowRenderer;\n\n    var customRowRendererProps = __assign(__assign({}, otherProps), {\n      renderBaseRow: function (p) {\n        return React.createElement(Row, __assign({\n          ref: ref\n        }, p));\n      }\n    });\n\n    if (isElement(CustomRowRenderer)) {\n      if (CustomRowRenderer.type === Row) {\n        // In the case where Row is specified as the custom render, ensure the correct ref is passed\n        return React.createElement(Row, __assign({}, props));\n      }\n\n      return React.cloneElement(CustomRowRenderer, customRowRendererProps);\n    }\n\n    return React.createElement(CustomRowRenderer, __assign({}, customRowRendererProps));\n  };\n\n  Canvas.prototype.renderGroupRow = function (props) {\n    var ref = props.ref,\n        columns = props.columns,\n        rowGroupProps = __rest(props, [\"ref\", \"columns\"]);\n\n    var row = props.row;\n    return React.createElement(RowGroup, __assign({}, rowGroupProps, row.__metaData, {\n      columns: columns,\n      name: row.name,\n      eventBus: this.props.eventBus,\n      renderer: this.props.rowGroupRenderer,\n      renderBaseRow: function (p) {\n        return React.createElement(Row, __assign({\n          ref: ref\n        }, p));\n      }\n    }));\n  };\n\n  Canvas.prototype.renderRow = function (props) {\n    var row = props.row;\n\n    if (row.__metaData && row.__metaData.getRowRenderer) {\n      return row.__metaData.getRowRenderer(this.props, props.idx);\n    }\n\n    if (row.__metaData && row.__metaData.isGroup) {\n      return this.renderGroupRow(props);\n    }\n\n    if (this.props.rowRenderer) {\n      return this.renderCustomRowRenderer(props);\n    }\n\n    return React.createElement(Row, __assign({}, props));\n  };\n\n  Canvas.prototype.renderPlaceholder = function (key, height) {\n    // just renders empty cells\n    // if we wanted to show gridlines, we'd need classes and position as with renderScrollingPlaceholder\n    return React.createElement(\"div\", {\n      key: key,\n      style: {\n        height: height\n      }\n    }, this.props.columns.map(function (column) {\n      return React.createElement(\"div\", {\n        style: {\n          width: column.width\n        },\n        key: column.key\n      });\n    }));\n  };\n\n  Canvas.prototype.render = function () {\n    var _this = this;\n\n    var _a = this.props,\n        rowOverscanStartIdx = _a.rowOverscanStartIdx,\n        rowOverscanEndIdx = _a.rowOverscanEndIdx,\n        cellMetaData = _a.cellMetaData,\n        columns = _a.columns,\n        colOverscanStartIdx = _a.colOverscanStartIdx,\n        colOverscanEndIdx = _a.colOverscanEndIdx,\n        colVisibleStartIdx = _a.colVisibleStartIdx,\n        colVisibleEndIdx = _a.colVisibleEndIdx,\n        lastFrozenColumnIndex = _a.lastFrozenColumnIndex,\n        rowHeight = _a.rowHeight,\n        rowsCount = _a.rowsCount,\n        totalColumnWidth = _a.totalColumnWidth,\n        totalWidth = _a.totalWidth,\n        height = _a.height,\n        rowGetter = _a.rowGetter,\n        contextMenu = _a.contextMenu;\n    var RowsContainer = this.props.RowsContainer || RowsContainerDefault;\n    var rows = this.getRows(rowOverscanStartIdx, rowOverscanEndIdx).map(function (_a, idx) {\n      var row = _a.row,\n          subRowDetails = _a.subRowDetails;\n      var rowIdx = rowOverscanStartIdx + idx;\n      return row && _this.renderRow({\n        key: rowIdx,\n        ref: function (row) {\n          if (row) {\n            _this.rows.set(rowIdx, row);\n          } else {\n            _this.rows.delete(rowIdx);\n          }\n        },\n        idx: rowIdx,\n        rowVisibleStartIdx: _this.props.rowVisibleStartIdx,\n        rowVisibleEndIdx: _this.props.rowVisibleEndIdx,\n        row: row,\n        height: rowHeight,\n        columns: columns,\n        isSelected: _this.isRowSelected(rowIdx, row),\n        cellMetaData: cellMetaData,\n        subRowDetails: subRowDetails,\n        colVisibleStartIdx: colVisibleStartIdx,\n        colVisibleEndIdx: colVisibleEndIdx,\n        colOverscanStartIdx: colOverscanStartIdx,\n        colOverscanEndIdx: colOverscanEndIdx,\n        lastFrozenColumnIndex: lastFrozenColumnIndex,\n        isScrolling: _this.props.isScrolling,\n        scrollLeft: _this._scroll.scrollLeft\n      });\n    });\n\n    if (rowOverscanStartIdx > 0) {\n      rows.unshift(this.renderPlaceholder('top', rowOverscanStartIdx * rowHeight));\n    }\n\n    if (rowsCount - rowOverscanEndIdx > 0) {\n      rows.push(this.renderPlaceholder('bottom', (rowsCount - rowOverscanEndIdx) * rowHeight));\n    }\n\n    return React.createElement(\"div\", {\n      className: \"react-grid-Canvas\",\n      style: {\n        width: totalWidth,\n        height: height\n      },\n      ref: this.canvas,\n      onScroll: this.handleScroll\n    }, React.createElement(InteractionMasks, __assign({\n      ref: this.interactionMasks,\n      rowGetter: rowGetter,\n      rowsCount: rowsCount,\n      rowHeight: rowHeight,\n      columns: columns,\n      rowVisibleStartIdx: this.props.rowVisibleStartIdx,\n      rowVisibleEndIdx: this.props.rowVisibleEndIdx,\n      colVisibleStartIdx: colVisibleStartIdx,\n      colVisibleEndIdx: colVisibleEndIdx,\n      enableCellSelect: this.props.enableCellSelect,\n      enableCellAutoFocus: this.props.enableCellAutoFocus,\n      cellNavigationMode: this.props.cellNavigationMode,\n      eventBus: this.props.eventBus,\n      contextMenu: this.props.contextMenu,\n      onHitBottomBoundary: this.onHitBottomCanvas,\n      onHitTopBoundary: this.onHitTopCanvas,\n      onHitLeftBoundary: this.handleHitColummBoundary,\n      onHitRightBoundary: this.handleHitColummBoundary,\n      scrollLeft: this._scroll.scrollLeft,\n      scrollTop: this._scroll.scrollTop,\n      getRowHeight: this.getRowHeight,\n      getRowTop: this.getRowTop,\n      getRowColumns: this.getRowColumns,\n      editorPortalTarget: this.props.editorPortalTarget\n    }, this.props.interactionMasksMetaData)), React.createElement(RowsContainer, {\n      id: contextMenu ? contextMenu.props.id : 'rowsContainer'\n    }, React.createElement(\"div\", {\n      style: {\n        width: totalColumnWidth\n      }\n    }, rows)));\n  };\n\n  Canvas.displayName = 'Canvas';\n  return Canvas;\n}(React.PureComponent);\n\nexport default Canvas;","map":{"version":3,"sources":["../src/Canvas.tsx"],"names":[],"mappings":"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","sourcesContent":["import React from 'react';\nimport { isElement } from 'react-is';\n\nimport Row from './Row';\nimport RowsContainerDefault from './RowsContainer';\nimport RowGroup from './RowGroup';\nimport { InteractionMasks } from './masks';\nimport * as rowUtils from './RowUtils';\nimport { getColumnScrollPosition } from './utils/canvasUtils';\nimport { EventTypes } from './common/enums';\nimport { CalculatedColumn, Position, ScrollPosition, SubRowDetails, RowRenderer, RowRendererProps, RowData } from './common/types';\nimport { ViewportProps, ViewportState } from './Viewport';\n\ntype SharedViewportProps<R> = Pick<ViewportProps<R>,\n'rowKey'\n| 'totalWidth'\n| 'rowGetter'\n| 'rowsCount'\n| 'selectedRows'\n| 'rowRenderer'\n| 'cellMetaData'\n| 'rowHeight'\n| 'scrollToRowIndex'\n| 'contextMenu'\n| 'rowSelection'\n| 'getSubRowDetails'\n| 'rowGroupRenderer'\n| 'enableCellSelect'\n| 'enableCellAutoFocus'\n| 'cellNavigationMode'\n| 'eventBus'\n| 'RowsContainer'\n| 'editorPortalTarget'\n| 'interactionMasksMetaData'\n>;\n\ntype SharedViewportState = Pick<ViewportState,\n'rowOverscanStartIdx'\n| 'rowOverscanEndIdx'\n| 'rowVisibleStartIdx'\n| 'rowVisibleEndIdx'\n| 'colVisibleStartIdx'\n| 'colVisibleEndIdx'\n| 'colOverscanStartIdx'\n| 'colOverscanEndIdx'\n| 'lastFrozenColumnIndex'\n| 'height'\n| 'isScrolling'\n>;\n\nexport interface CanvasProps<R> extends SharedViewportProps<R>, SharedViewportState {\n  columns: CalculatedColumn<R>[];\n  width: number;\n  totalColumnWidth: number;\n  onScroll(position: ScrollPosition): void;\n}\n\ntype RendererProps<R> = Pick<CanvasProps<R>, 'rowVisibleStartIdx' | 'rowVisibleEndIdx' | 'columns' | 'cellMetaData' | 'colVisibleStartIdx' | 'colVisibleEndIdx' | 'colOverscanEndIdx' | 'colOverscanStartIdx' | 'lastFrozenColumnIndex' | 'isScrolling'> & {\n  ref(row: (RowRenderer<R> & React.Component<RowRendererProps<R>>) | null): void;\n  key: number;\n  idx: number;\n  row: R;\n  subRowDetails?: SubRowDetails;\n  height: number;\n  isSelected: boolean;\n  scrollLeft: number;\n};\n\nexport default class Canvas<R> extends React.PureComponent<CanvasProps<R>> {\n  static displayName = 'Canvas';\n\n  private readonly canvas = React.createRef<HTMLDivElement>();\n  private readonly interactionMasks = React.createRef<InteractionMasks<R>>();\n  private readonly rows = new Map<number, RowRenderer<R> & React.Component<RowRendererProps<R>>>();\n  private unsubscribeScrollToColumn?(): void;\n  private _scroll = { scrollTop: 0, scrollLeft: 0 };\n\n  componentDidMount() {\n    this.unsubscribeScrollToColumn = this.props.eventBus.subscribe(EventTypes.SCROLL_TO_COLUMN, this.scrollToColumn);\n  }\n\n  componentWillUnmount() {\n    this.unsubscribeScrollToColumn!();\n  }\n\n  componentDidUpdate(prevProps: CanvasProps<R>) {\n    const { scrollToRowIndex } = this.props;\n    if (scrollToRowIndex && prevProps.scrollToRowIndex !== scrollToRowIndex) {\n      this.scrollToRow(scrollToRowIndex);\n    }\n  }\n\n  handleScroll = (e: React.UIEvent<HTMLDivElement>) => {\n    const { scrollLeft, scrollTop } = e.currentTarget;\n    this._scroll = { scrollTop, scrollLeft };\n    if (this.props.onScroll) {\n      this.props.onScroll(this._scroll);\n    }\n  };\n\n  onHitBottomCanvas = () => {\n    const { current } = this.canvas;\n    if (current) {\n      current.scrollTop += this.props.rowHeight + this.getClientScrollTopOffset(current);\n    }\n  };\n\n  onHitTopCanvas = () => {\n    const { current } = this.canvas;\n    if (current) {\n      current.scrollTop -= this.props.rowHeight - this.getClientScrollTopOffset(current);\n    }\n  };\n\n  handleHitColummBoundary = ({ idx }: Position) => {\n    this.scrollToColumn(idx);\n  };\n\n  scrollToRow(scrollToRowIndex: number) {\n    const { current } = this.canvas;\n    if (!current) return;\n    const { rowHeight, rowsCount, height } = this.props;\n    current.scrollTop = Math.min(\n      scrollToRowIndex * rowHeight,\n      rowsCount * rowHeight - height\n    );\n  }\n\n  scrollToColumn = (idx: number) => {\n    const { current } = this.canvas;\n    if (!current) return;\n\n    const { scrollLeft, clientWidth } = current;\n    const newScrollLeft = getColumnScrollPosition(this.props.columns, idx, scrollLeft, clientWidth);\n    if (newScrollLeft !== 0) {\n      current.scrollLeft = scrollLeft + newScrollLeft;\n    }\n  };\n\n  getRows(rowOverscanStartIdx: number, rowOverscanEndIdx: number) {\n    const rows = [];\n    let i = rowOverscanStartIdx;\n    while (i < rowOverscanEndIdx) {\n      const row = this.props.rowGetter(i);\n      let subRowDetails: SubRowDetails | undefined;\n      if (this.props.getSubRowDetails) {\n        subRowDetails = this.props.getSubRowDetails(row);\n      }\n      rows.push({ row, subRowDetails });\n      i++;\n    }\n    return rows;\n  }\n\n  getScroll() {\n    const { scrollTop, scrollLeft } = this.canvas.current!;\n    return { scrollTop, scrollLeft };\n  }\n\n  getClientScrollTopOffset(node: HTMLDivElement) {\n    const { rowHeight } = this.props;\n    const scrollVariation = node.scrollTop % rowHeight;\n    return scrollVariation > 0 ? rowHeight - scrollVariation : 0;\n  }\n\n  isRowSelected(idx: number, row: R) {\n    // Use selectedRows if set\n    if (this.props.selectedRows) {\n      const selectedRow = this.props.selectedRows.find(r => {\n        const rowKeyValue = rowUtils.get(row, this.props.rowKey);\n        return r[this.props.rowKey] === rowKeyValue;\n      });\n      return !!(selectedRow && selectedRow.isSelected);\n    }\n\n    // Else use new rowSelection props\n    if (this.props.rowSelection) {\n      const { keys, indexes, isSelectedKey } = this.props.rowSelection as { [key: string]: unknown };\n      return rowUtils.isRowSelected(keys as { rowKey?: string; values?: string[] } | null, indexes as number[] | null, isSelectedKey as string | null, row, idx);\n    }\n\n    return false;\n  }\n\n  setScrollLeft(scrollLeft: number) {\n    const { current } = this.interactionMasks;\n    if (current) {\n      current.setScrollLeft(scrollLeft);\n    }\n\n    this.rows.forEach((r, idx) => {\n      const row = this.getRowByRef(idx);\n      if (row && row.setScrollLeft) {\n        row.setScrollLeft(scrollLeft);\n      }\n    });\n  }\n\n  getRowByRef = (i: number) => {\n    // check if wrapped with React DND drop target\n    if (!this.rows.has(i)) return;\n\n    const row = this.rows.get(i)!;\n    const wrappedRow = row.getDecoratedComponentInstance ? row.getDecoratedComponentInstance(i) : null;\n    return wrappedRow ? wrappedRow.row : row;\n  };\n\n  getRowTop = (rowIdx: number) => {\n    const row = this.getRowByRef(rowIdx);\n    if (row && row.getRowTop) {\n      return row.getRowTop();\n    }\n    return this.props.rowHeight * rowIdx;\n  };\n\n  getRowHeight = (rowIdx: number) => {\n    const row = this.getRowByRef(rowIdx);\n    if (row && row.getRowHeight) {\n      return row.getRowHeight();\n    }\n    return this.props.rowHeight;\n  };\n\n  getRowColumns = (rowIdx: number) => {\n    const row = this.getRowByRef(rowIdx);\n    return row && row.props ? row.props.columns : this.props.columns;\n  };\n\n  renderCustomRowRenderer(props: RendererProps<R>) {\n    const { ref, ...otherProps } = props;\n    const CustomRowRenderer = this.props.rowRenderer!;\n    const customRowRendererProps = { ...otherProps, renderBaseRow: (p: RowRendererProps<R>) => <Row ref={ref} {...p} /> };\n\n    if (isElement(CustomRowRenderer)) {\n      if (CustomRowRenderer.type === Row) {\n        // In the case where Row is specified as the custom render, ensure the correct ref is passed\n        return <Row<R> {...props} />;\n      }\n      return React.cloneElement(CustomRowRenderer, customRowRendererProps);\n    }\n\n    return <CustomRowRenderer {...customRowRendererProps} />;\n  }\n\n  renderGroupRow(props: RendererProps<R>) {\n    const { ref, columns, ...rowGroupProps } = props;\n    const row = props.row as RowData;\n\n    return (\n      <RowGroup\n        {...rowGroupProps}\n        {...row.__metaData!}\n        columns={columns as CalculatedColumn<unknown>[]}\n        name={row.name!}\n        eventBus={this.props.eventBus}\n        renderer={this.props.rowGroupRenderer}\n        renderBaseRow={(p: RowRendererProps<R>) => <Row ref={ref} {...p} />}\n      />\n    );\n  }\n\n  renderRow(props: RendererProps<R>) {\n    const row = props.row as RowData;\n\n    if (row.__metaData && row.__metaData.getRowRenderer) {\n      return row.__metaData.getRowRenderer(this.props, props.idx);\n    }\n    if (row.__metaData && row.__metaData.isGroup) {\n      return this.renderGroupRow(props);\n    }\n\n    if (this.props.rowRenderer) {\n      return this.renderCustomRowRenderer(props);\n    }\n\n    return <Row<R> {...props} />;\n  }\n\n  renderPlaceholder(key: string, height: number) {\n    // just renders empty cells\n    // if we wanted to show gridlines, we'd need classes and position as with renderScrollingPlaceholder\n    return (\n      <div key={key} style={{ height }}>\n        {this.props.columns.map(column => <div style={{ width: column.width }} key={column.key as string} />)}\n      </div>\n    );\n  }\n\n  render() {\n    const { rowOverscanStartIdx, rowOverscanEndIdx, cellMetaData, columns, colOverscanStartIdx, colOverscanEndIdx, colVisibleStartIdx, colVisibleEndIdx, lastFrozenColumnIndex, rowHeight, rowsCount, totalColumnWidth, totalWidth, height, rowGetter, contextMenu } = this.props;\n    const RowsContainer = this.props.RowsContainer || RowsContainerDefault;\n\n    const rows = this.getRows(rowOverscanStartIdx, rowOverscanEndIdx)\n      .map(({ row, subRowDetails }, idx) => {\n        const rowIdx = rowOverscanStartIdx + idx;\n        return row && this.renderRow({\n          key: rowIdx,\n          ref: (row: (RowRenderer<R> & React.Component<RowRendererProps<R>>) | null) => {\n            if (row) {\n              this.rows.set(rowIdx, row);\n            } else {\n              this.rows.delete(rowIdx);\n            }\n          },\n          idx: rowIdx,\n          rowVisibleStartIdx: this.props.rowVisibleStartIdx,\n          rowVisibleEndIdx: this.props.rowVisibleEndIdx,\n          row,\n          height: rowHeight,\n          columns,\n          isSelected: this.isRowSelected(rowIdx, row),\n          cellMetaData,\n          subRowDetails,\n          colVisibleStartIdx,\n          colVisibleEndIdx,\n          colOverscanStartIdx,\n          colOverscanEndIdx,\n          lastFrozenColumnIndex,\n          isScrolling: this.props.isScrolling,\n          scrollLeft: this._scroll.scrollLeft\n        });\n      });\n\n    if (rowOverscanStartIdx > 0) {\n      rows.unshift(this.renderPlaceholder('top', rowOverscanStartIdx * rowHeight));\n    }\n\n    if (rowsCount - rowOverscanEndIdx > 0) {\n      rows.push(this.renderPlaceholder('bottom', (rowsCount - rowOverscanEndIdx) * rowHeight));\n    }\n\n    return (\n      <div\n        className=\"react-grid-Canvas\"\n        style={{ width: totalWidth, height }}\n        ref={this.canvas}\n        onScroll={this.handleScroll}\n      >\n        <InteractionMasks<R>\n          ref={this.interactionMasks}\n          rowGetter={rowGetter}\n          rowsCount={rowsCount}\n          rowHeight={rowHeight}\n          columns={columns}\n          rowVisibleStartIdx={this.props.rowVisibleStartIdx}\n          rowVisibleEndIdx={this.props.rowVisibleEndIdx}\n          colVisibleStartIdx={colVisibleStartIdx}\n          colVisibleEndIdx={colVisibleEndIdx}\n          enableCellSelect={this.props.enableCellSelect}\n          enableCellAutoFocus={this.props.enableCellAutoFocus}\n          cellNavigationMode={this.props.cellNavigationMode}\n          eventBus={this.props.eventBus}\n          contextMenu={this.props.contextMenu}\n          onHitBottomBoundary={this.onHitBottomCanvas}\n          onHitTopBoundary={this.onHitTopCanvas}\n          onHitLeftBoundary={this.handleHitColummBoundary}\n          onHitRightBoundary={this.handleHitColummBoundary}\n          scrollLeft={this._scroll.scrollLeft}\n          scrollTop={this._scroll.scrollTop}\n          getRowHeight={this.getRowHeight}\n          getRowTop={this.getRowTop}\n          getRowColumns={this.getRowColumns}\n          editorPortalTarget={this.props.editorPortalTarget}\n          {...this.props.interactionMasksMetaData}\n        />\n        <RowsContainer id={contextMenu ? contextMenu.props.id : 'rowsContainer'}>\n          <div style={{ width: totalColumnWidth }}>{rows}</div>\n        </RowsContainer>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}