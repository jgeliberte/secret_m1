{"ast":null,"code":"import { __extends, __values } from \"tslib\";\nimport React from 'react';\nimport shallowEqual from 'shallowequal';\nimport HeaderCell from './HeaderCell';\nimport SortableHeaderCell from './common/cells/headerCells/SortableHeaderCell';\nimport FilterableHeaderCell from './common/cells/headerCells/FilterableHeaderCell';\nimport getScrollbarSize from './getScrollbarSize';\nimport { isFrozen } from './ColumnUtils';\nimport { HeaderRowType, HeaderCellType, DEFINE_SORT } from './common/enums';\n\nvar HeaderRow =\n/** @class */\nfunction (_super) {\n  __extends(HeaderRow, _super);\n\n  function HeaderRow() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.cells = new Map();\n    return _this;\n  }\n\n  HeaderRow.prototype.shouldComponentUpdate = function (nextProps) {\n    return nextProps.width !== this.props.width || nextProps.height !== this.props.height || nextProps.columns !== this.props.columns || !shallowEqual(nextProps.style, this.props.style) || this.props.sortColumn !== nextProps.sortColumn || this.props.sortDirection !== nextProps.sortDirection;\n  };\n\n  HeaderRow.prototype.getHeaderCellType = function (column) {\n    if (column.filterable && this.props.filterable) {\n      return HeaderCellType.FILTERABLE;\n    }\n\n    if (column.sortable && this.props.rowType !== HeaderRowType.FILTER) {\n      return HeaderCellType.SORTABLE;\n    }\n\n    return HeaderCellType.NONE;\n  };\n\n  HeaderRow.prototype.getFilterableHeaderCell = function (column) {\n    var FilterRenderer = column.filterRenderer || FilterableHeaderCell;\n    return React.createElement(FilterRenderer, {\n      column: column,\n      onChange: this.props.onFilterChange,\n      getValidFilterValues: this.props.getValidFilterValues\n    });\n  };\n\n  HeaderRow.prototype.getSortableHeaderCell = function (column) {\n    var sortDirection = this.props.sortColumn === column.key && this.props.sortDirection || DEFINE_SORT.NONE;\n    var sortDescendingFirst = column.sortDescendingFirst || false;\n    return React.createElement(SortableHeaderCell, {\n      column: column,\n      rowType: this.props.rowType,\n      onSort: this.props.onSort,\n      sortDirection: sortDirection,\n      sortDescendingFirst: sortDescendingFirst\n    });\n  };\n\n  HeaderRow.prototype.getHeaderRenderer = function (column) {\n    if (column.headerRenderer && !column.sortable && !this.props.filterable) {\n      return column.headerRenderer;\n    }\n\n    var headerCellType = this.getHeaderCellType(column);\n\n    switch (headerCellType) {\n      case HeaderCellType.SORTABLE:\n        return this.getSortableHeaderCell(column);\n\n      case HeaderCellType.FILTERABLE:\n        return this.getFilterableHeaderCell(column);\n\n      default:\n        return undefined;\n    }\n  };\n\n  HeaderRow.prototype.getCells = function () {\n    var e_1, _a;\n\n    var _this = this;\n\n    var cells = [];\n    var frozenCells = [];\n    var _b = this.props,\n        columns = _b.columns,\n        rowType = _b.rowType;\n\n    var _loop_1 = function (column) {\n      var key = column.key;\n      var renderer = key === 'select-row' && rowType === HeaderRowType.FILTER ? React.createElement(\"div\", null) : this_1.getHeaderRenderer(column);\n      var cell = React.createElement(HeaderCell, {\n        key: key,\n        ref: function (node) {\n          return node ? _this.cells.set(key, node) : _this.cells.delete(key);\n        },\n        column: column,\n        rowType: rowType,\n        height: this_1.props.height,\n        renderer: renderer,\n        onResize: this_1.props.onColumnResize,\n        onResizeEnd: this_1.props.onColumnResizeEnd,\n        onHeaderDrop: this_1.props.onHeaderDrop,\n        draggableHeaderCell: this_1.props.draggableHeaderCell\n      });\n\n      if (isFrozen(column)) {\n        frozenCells.push(cell);\n      } else {\n        cells.push(cell);\n      }\n    };\n\n    var this_1 = this;\n\n    try {\n      for (var columns_1 = __values(columns), columns_1_1 = columns_1.next(); !columns_1_1.done; columns_1_1 = columns_1.next()) {\n        var column = columns_1_1.value;\n\n        _loop_1(column);\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (columns_1_1 && !columns_1_1.done && (_a = columns_1.return)) _a.call(columns_1);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n\n    return cells.concat(frozenCells);\n  };\n\n  HeaderRow.prototype.setScrollLeft = function (scrollLeft) {\n    var _this = this;\n\n    this.props.columns.forEach(function (column) {\n      var key = column.key;\n      if (!_this.cells.has(key)) return;\n\n      var cell = _this.cells.get(key);\n\n      if (isFrozen(column)) {\n        cell.setScrollLeft(scrollLeft);\n      } else {\n        cell.removeScroll();\n      }\n    });\n  };\n\n  HeaderRow.prototype.render = function () {\n    var cellsStyle = {\n      width: this.props.width ? this.props.width + getScrollbarSize() : '100%',\n      height: this.props.height\n    }; // FIXME: do we need 2 wrapping divs?\n\n    return React.createElement(\"div\", {\n      style: this.props.style,\n      className: \"react-grid-HeaderRow\"\n    }, React.createElement(\"div\", {\n      style: cellsStyle\n    }, this.getCells()));\n  };\n\n  HeaderRow.displayName = 'HeaderRow';\n  return HeaderRow;\n}(React.Component);\n\nexport default HeaderRow;","map":{"version":3,"sources":["../src/HeaderRow.tsx"],"names":[],"mappings":"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","sourcesContent":["import React from 'react';\nimport shallowEqual from 'shallowequal';\n\nimport HeaderCell from './HeaderCell';\nimport SortableHeaderCell from './common/cells/headerCells/SortableHeaderCell';\nimport FilterableHeaderCell from './common/cells/headerCells/FilterableHeaderCell';\nimport getScrollbarSize from './getScrollbarSize';\nimport { isFrozen } from './ColumnUtils';\nimport { HeaderRowType, HeaderCellType, DEFINE_SORT } from './common/enums';\nimport { CalculatedColumn, AddFilterEvent } from './common/types';\nimport { HeaderProps } from './Header';\n\ntype SharedHeaderProps<R> = Pick<HeaderProps<R>,\n'draggableHeaderCell'\n| 'onHeaderDrop'\n| 'sortColumn'\n| 'sortDirection'\n| 'onSort'\n| 'getValidFilterValues'\n>;\n\nexport interface HeaderRowProps<R> extends SharedHeaderProps<R> {\n  width?: number;\n  height: number;\n  columns: CalculatedColumn<R>[];\n  onColumnResize(column: CalculatedColumn<R>, width: number): void;\n  onColumnResizeEnd(column: CalculatedColumn<R>, width: number): void;\n  style?: React.CSSProperties;\n  filterable?: boolean;\n  onFilterChange?(args: AddFilterEvent<R>): void;\n  rowType: HeaderRowType;\n}\n\nexport default class HeaderRow<R> extends React.Component<HeaderRowProps<R>> {\n  static displayName = 'HeaderRow';\n\n  private readonly cells = new Map<keyof R, HeaderCell<R>>();\n\n  shouldComponentUpdate(nextProps: HeaderRowProps<R>) {\n    return (\n      nextProps.width !== this.props.width\n      || nextProps.height !== this.props.height\n      || nextProps.columns !== this.props.columns\n      || !shallowEqual(nextProps.style, this.props.style)\n      || this.props.sortColumn !== nextProps.sortColumn\n      || this.props.sortDirection !== nextProps.sortDirection\n    );\n  }\n\n  getHeaderCellType(column: CalculatedColumn<R>): HeaderCellType {\n    if (column.filterable && this.props.filterable) {\n      return HeaderCellType.FILTERABLE;\n    }\n\n    if (column.sortable && this.props.rowType !== HeaderRowType.FILTER) {\n      return HeaderCellType.SORTABLE;\n    }\n\n    return HeaderCellType.NONE;\n  }\n\n  getFilterableHeaderCell(column: CalculatedColumn<R>) {\n    const FilterRenderer = column.filterRenderer || FilterableHeaderCell;\n    return (\n      <FilterRenderer<R>\n        column={column}\n        onChange={this.props.onFilterChange}\n        getValidFilterValues={this.props.getValidFilterValues}\n      />\n    );\n  }\n\n  getSortableHeaderCell(column: CalculatedColumn<R>) {\n    const sortDirection = this.props.sortColumn === column.key && this.props.sortDirection || DEFINE_SORT.NONE;\n    const sortDescendingFirst = column.sortDescendingFirst || false;\n    return (\n      <SortableHeaderCell<R>\n        column={column}\n        rowType={this.props.rowType}\n        onSort={this.props.onSort}\n        sortDirection={sortDirection}\n        sortDescendingFirst={sortDescendingFirst}\n      />\n    );\n  }\n\n  getHeaderRenderer(column: CalculatedColumn<R>) {\n    if (column.headerRenderer && !column.sortable && !this.props.filterable) {\n      return column.headerRenderer;\n    }\n    const headerCellType = this.getHeaderCellType(column);\n    switch (headerCellType) {\n      case HeaderCellType.SORTABLE:\n        return this.getSortableHeaderCell(column);\n      case HeaderCellType.FILTERABLE:\n        return this.getFilterableHeaderCell(column);\n      default:\n        return undefined;\n    }\n  }\n\n  getCells() {\n    const cells = [];\n    const frozenCells = [];\n    const { columns, rowType } = this.props;\n\n    for (const column of columns) {\n      const { key } = column;\n      const renderer = key === 'select-row' && rowType === HeaderRowType.FILTER ? <div /> : this.getHeaderRenderer(column);\n\n      const cell = (\n        <HeaderCell<R>\n          key={key as string}\n          ref={node => node ? this.cells.set(key, node) : this.cells.delete(key)}\n          column={column}\n          rowType={rowType}\n          height={this.props.height}\n          renderer={renderer}\n          onResize={this.props.onColumnResize}\n          onResizeEnd={this.props.onColumnResizeEnd}\n          onHeaderDrop={this.props.onHeaderDrop}\n          draggableHeaderCell={this.props.draggableHeaderCell}\n        />\n      );\n\n      if (isFrozen(column)) {\n        frozenCells.push(cell);\n      } else {\n        cells.push(cell);\n      }\n    }\n\n    return cells.concat(frozenCells);\n  }\n\n  setScrollLeft(scrollLeft: number): void {\n    this.props.columns.forEach(column => {\n      const { key } = column;\n      if (!this.cells.has(key)) return;\n      const cell = this.cells.get(key)!;\n      if (isFrozen(column)) {\n        cell.setScrollLeft(scrollLeft);\n      } else {\n        cell.removeScroll();\n      }\n    });\n  }\n\n  render() {\n    const cellsStyle: React.CSSProperties = {\n      width: this.props.width ? this.props.width + getScrollbarSize() : '100%',\n      height: this.props.height\n    };\n\n    // FIXME: do we need 2 wrapping divs?\n    return (\n      <div\n        style={this.props.style}\n        className=\"react-grid-HeaderRow\"\n      >\n        <div style={cellsStyle}>\n          {this.getCells()}\n        </div>\n      </div>\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}